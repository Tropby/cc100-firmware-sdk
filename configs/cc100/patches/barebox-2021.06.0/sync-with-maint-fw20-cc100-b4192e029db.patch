diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 00000000000..f81a79ff831
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,4 @@
+[submodule "labgrid-wago"]
+	path = labgrid-wago
+	url = ssh://svtfs01007:22/tfs/ProductDevelopment/Linux-BSP/_git/labgrid-wago
+	ignore = dirty
diff --git a/Documentation/user/booting-linux.rst b/Documentation/user/booting-linux.rst
index 60babb513ce..b6889238479 100644
--- a/Documentation/user/booting-linux.rst
+++ b/Documentation/user/booting-linux.rst
@@ -225,6 +225,14 @@ compatible NFS URI string must be passed to the boot command:
 
   boot nfs://nfshost[:port]//path/
 
+Barebox can choose certain Bootloader Spec config files directly. That avoids searching
+for the right bootentrie. Pass the path of a certain Bootloader Spec config file with
+``file://`` prefix to the boot command:
+
+.. code-block:: sh
+
+  boot file://path/loader/entries/filename.conf
+
 Additionally to the options defined in the original spec barebox understands the
 ``linux-appendroot`` option. This is a boolean value and if set to ``true`` barebox
 will automatically append a ``root=`` string to the Linux commandline based on the
diff --git a/arch/arm/boards/Makefile b/arch/arm/boards/Makefile
index 40b0af8d30b..c5b8d0e3777 100644
--- a/arch/arm/boards/Makefile
+++ b/arch/arm/boards/Makefile
@@ -135,6 +135,7 @@ obj-$(CONFIG_MACH_SOLIDRUN_MICROSOM)		+= solidrun-microsom/
 obj-$(CONFIG_MACH_STM32MP15XX_DKX)		+= stm32mp15xx-dkx/
 obj-$(CONFIG_MACH_LXA_MC1)			+= lxa-mc1/
 obj-$(CONFIG_MACH_STM32MP15X_EV1)		+= stm32mp15x-ev1/
+obj-$(CONFIG_MACH_STM32MP151_CC100)		+= stm32mp151-cc100/
 obj-$(CONFIG_MACH_TECHNEXION_PICO_HOBBIT)	+= technexion-pico-hobbit/
 obj-$(CONFIG_MACH_TECHNEXION_WANDBOARD)		+= technexion-wandboard/
 obj-$(CONFIG_MACH_TNY_A9260)			+= tny-a926x/
diff --git a/arch/arm/boards/stm32mp151-cc100/Makefile b/arch/arm/boards/stm32mp151-cc100/Makefile
new file mode 100644
index 00000000000..ce2e8582802
--- /dev/null
+++ b/arch/arm/boards/stm32mp151-cc100/Makefile
@@ -0,0 +1,3 @@
+lwl-y += lowlevel.o
+obj-y += board.o
+bbenv-y += defaultenv-stm32mp151-cc100
diff --git a/arch/arm/boards/stm32mp151-cc100/board.c b/arch/arm/boards/stm32mp151-cc100/board.c
new file mode 100644
index 00000000000..4e152053152
--- /dev/null
+++ b/arch/arm/boards/stm32mp151-cc100/board.c
@@ -0,0 +1,170 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+#include <bootsource.h>
+#include <common.h>
+#include <init.h>
+#include <mach/bbu.h>
+#include <envfs.h>
+#include <xsection.h>
+#include <globalvar.h>
+#include <linux/micrel_phy.h>
+#include <net.h>
+#include <gpio.h>
+
+#define ETH_DEVICE_0 0
+#define ETH_DEVICE_1 1
+
+#define KSZ8863_GLOBAL_CONTROL_4		0x06
+#define KSZ8863_PORT1_Q0_INGRESS_DATA_RATE	0x16
+#define KSZ8863_PORT1_GLOBAL_CONTRL12		0x1c
+#define KSZ8863_PORT1_GLOBAL_CONTRL13		0x1d
+#define KSZ8863_PORT1_STATUS1			0x1f
+
+static int cc100_set_ethaddr(void)
+{
+	u8 mac[6];
+	int ret;
+
+	ret = xsection_get_ethaddr1(mac);
+	if (ret < 0)
+		return ret;
+
+	eth_register_ethaddr(ETH_DEVICE_0, mac);
+	eth_register_ethaddr(ETH_DEVICE_1, mac);
+
+	return 0;
+}
+
+static int ksz8863_phy_fixup(struct phy_device *phydev)
+{
+	phy_write(phydev, KSZ8863_PORT1_STATUS1, 0x8190);
+	phy_write(phydev, KSZ8863_PORT1_Q0_INGRESS_DATA_RATE, 0x202);
+	phy_write(phydev, KSZ8863_GLOBAL_CONTROL_4, 0x30);
+	phy_write(phydev, KSZ8863_PORT1_GLOBAL_CONTRL12, 0x9f);
+	phy_write(phydev, KSZ8863_PORT1_GLOBAL_CONTRL13, 0x00);
+
+	return 0;
+}
+
+static int cc100_ksz8863_setup(void)
+{
+	int ret = 0;
+
+	phy_register_fixup_for_uid(PHY_ID_KSZ8863, MICREL_PHY_ID_MASK,
+							ksz8863_phy_fixup);
+
+	return ret;
+}
+fs_initcall(cc100_ksz8863_setup);
+
+static int rewrite_compatible(void)
+{
+	struct device_node *root;
+	int ret;
+	u16 devconf;
+	char const *first_compat_str;
+	char *new_string;
+
+	ret = xsection_get_devconf(&devconf);
+	if (ret < 0)
+		goto out;
+
+	root = of_get_root_node();
+	if (!root) {
+		ret = -ENOENT;
+		goto out;
+	}
+
+	ret = of_property_read_string_index(root, "compatible", 0, &first_compat_str);
+	if (ret < 0)
+		goto out;
+
+	new_string = basprintf("%s-%04x", first_compat_str, devconf);
+	if (!new_string) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	ret = of_property_write_string(root, "compatible", new_string);
+	free(new_string);
+
+out:
+	return ret < 0 ? ret : 0;
+}
+
+static int stm32mp151_cc100_late_init(void)
+{
+	int ret;
+	const char *s;
+
+	ret = of_property_read_string(of_get_root_node(), "board-variant", &s);
+	if (!ret) {
+		globalvar_add_simple("board.variant", s);
+	} else {
+		pr_warn("failed to get board.variant from oftree\n");
+	}
+
+	/* Rewrite the compatible string in the internal barebox device-tree
+	 * (located in ram), and add the eeprom devconf as suffix. This string
+	 * is used by the bootloader-spec module to search for correct bootloader-spec
+	 * entry to load the corrosponding kernel device-tree.
+	 */
+	ret = rewrite_compatible();
+	if (ret < 0)
+		pr_err("failed to rewrite the internal compatible string "
+			"with devconf from eeprom, returned %i\n", ret);
+
+	ret = cc100_set_ethaddr();
+	if (ret < 0)
+		pr_info("no valid ethaddr in eeprom found. Using randomized MAC address\n");
+
+	//  switch the led-mmc on, if booted from mmc
+	if ((bootsource_get() == BOOTSOURCE_MMC) &&
+	    (bootsource_get_instance() == 0)) {
+
+		int gpio_led_mmc = gpio_find_by_label("led-mmc");
+		if (gpio_led_mmc < 0)
+			pr_err("mmc led out of order because gpio led-mmc \
+				not found in dts\n");
+		else
+			gpio_direction_output(gpio_led_mmc, 1);
+	}
+
+	return ret;
+}
+late_initcall(stm32mp151_cc100_late_init);
+
+
+static int stm32mp151_cc100_probe(struct device_d *dev)
+{
+	int flags;
+
+	flags = bootsource_get_instance() == 0 ? BBU_HANDLER_FLAG_DEFAULT : 0;
+	stm32mp_bbu_mmc_register_handler("sd", "/dev/mmc0.ssbl", flags);
+
+	flags = bootsource_get_instance() == 1 ? BBU_HANDLER_FLAG_DEFAULT : 0;
+	stm32mp_bbu_mmc_register_handler("emmc", "/dev/mmc1.ssbl", flags);
+
+	defaultenv_append_directory(defaultenv_stm32mp151_cc100);
+
+	if (bootsource_get_instance() == 0)
+		of_device_enable_path("/chosen/environment-sd");
+	else
+		of_device_enable_path("/chosen/environment-emmc");
+
+	barebox_set_model("STM32MP151-CC100");
+
+	return 0;
+}
+
+static const struct of_device_id stm32mp151_cc100_of_match[] = {
+	{ .compatible = "st,stm32mp151_cc100" },
+	{ /* sentinel */ },
+};
+
+static struct driver_d stm32mp151_cc100_board_driver = {
+	.name = "board-stm32mp151_cc100",
+	.probe = stm32mp151_cc100_probe,
+	.of_compatible = stm32mp151_cc100_of_match,
+};
+postcore_platform_driver(stm32mp151_cc100_board_driver);
diff --git a/arch/arm/boards/stm32mp151-cc100/defaultenv-stm32mp151-cc100/init/aa-cc100-setup-board-env b/arch/arm/boards/stm32mp151-cc100/defaultenv-stm32mp151-cc100/init/aa-cc100-setup-board-env
new file mode 100644
index 00000000000..860a8abb085
--- /dev/null
+++ b/arch/arm/boards/stm32mp151-cc100/defaultenv-stm32mp151-cc100/init/aa-cc100-setup-board-env
@@ -0,0 +1,19 @@
+#!/bin/sh
+
+# set variables for vtpctp
+
+global.pfc.emmc_dev_rootfs0="/dev/mmc1.4"
+global.pfc.emmc_dev_rootfs1="/dev/mmc1.7"
+
+# this is only a workaround until the boot partition on the sd-card is
+# available
+global.pfc.sd_dev_boot="/dev/mmc0.99"
+
+global.pfc.sd_dev_rootfs="/dev/mmc0.4"
+
+global.pfc.linux_uart_device="ttySTM"
+global.pfc.barebox_uart="0"
+
+# Linux driver of the internal watchdog does not support module parameterization.
+# Thus the watchdog timeout has to be set in appropriate DTS file (timeout-sec).
+global.linux.bootargs.watchdog=""
diff --git a/arch/arm/boards/stm32mp151-cc100/lowlevel.c b/arch/arm/boards/stm32mp151-cc100/lowlevel.c
new file mode 100644
index 00000000000..c753e5c84c5
--- /dev/null
+++ b/arch/arm/boards/stm32mp151-cc100/lowlevel.c
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier: GPL-2.0+
+#include <common.h>
+#include <mach/entry.h>
+#include <debug_ll.h>
+
+extern char __dtb_z_stm32mp151_cc100_start[];
+
+static void setup_uart(void)
+{
+	/* first stage has set up the UART, so nothing to do here */
+	putc_ll('>');
+}
+
+ENTRY_FUNCTION(start_stm32mp151_cc100, r0, r1, r2)
+{
+	void *fdt;
+
+	stm32mp_cpu_lowlevel_init();
+
+	if (IS_ENABLED(CONFIG_DEBUG_LL))
+		setup_uart();
+
+	fdt = __dtb_z_stm32mp151_cc100_start + get_runtime_offset();
+
+	stm32mp1_barebox_entry(fdt);
+}
diff --git a/arch/arm/configs/stm32mp_cc100_defconfig b/arch/arm/configs/stm32mp_cc100_defconfig
new file mode 100644
index 00000000000..e2e764eac15
--- /dev/null
+++ b/arch/arm/configs/stm32mp_cc100_defconfig
@@ -0,0 +1,173 @@
+CONFIG_ARCH_STM32MP=y
+CONFIG_MACH_STM32MP151_CC100=y
+CONFIG_THUMB2_BAREBOX=y
+CONFIG_ARM_BOARD_APPEND_ATAG=y
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_ARM_UNWIND=y
+CONFIG_MMU=y
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_TLSF=y
+CONFIG_KALLSYMS=y
+CONFIG_RELOCATABLE=y
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+CONFIG_BOOTM_SHOW_TYPE=y
+CONFIG_BOOTM_VERBOSE=y
+CONFIG_BOOTM_INITRD=y
+CONFIG_BOOTM_OFTREE=y
+CONFIG_BOOTM_OFTREE_UIMAGE=y
+CONFIG_BLSPEC=y
+CONFIG_CONSOLE_ACTIVATE_NONE=y
+CONFIG_CONSOLE_ALLOW_COLOR=y
+CONFIG_PBL_CONSOLE=y
+CONFIG_CONSOLE_RATP=y
+CONFIG_RATP_CMD_I2C=y
+CONFIG_RATP_CMD_GPIO=y
+CONFIG_PARTITION_DISK_EFI=y
+# CONFIG_PARTITION_DISK_EFI_GPT_NO_FORCE is not set
+# CONFIG_PARTITION_DISK_EFI_GPT_COMPARE is not set
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW_REBOOT_MODE=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="defaultenv/defaultenv-pfc-base/ arch/arm/boards/stm32mp151-cc100/defaultenv-stm32mp151-cc100/"
+CONFIG_STATE=y
+CONFIG_BOOTCHOOSER=y
+CONFIG_RESET_SOURCE=y
+CONFIG_CMD_DMESG=y
+CONFIG_LONGHELP=y
+CONFIG_CMD_IOMEM=y
+CONFIG_CMD_IMD=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_ARM_MMUINFO=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_MMC_EXTCSD=y
+# CONFIG_CMD_BOOTU is not set
+CONFIG_CMD_GO=y
+CONFIG_CMD_RESET=y
+CONFIG_CMD_UIMAGE=y
+CONFIG_CMD_BOOTCHOOSER=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_LOADENV=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_FILETYPE=y
+CONFIG_CMD_LN=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_UNCOMPRESS=y
+CONFIG_CMD_LET=y
+CONFIG_CMD_MSLEEP=y
+CONFIG_CMD_READF=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MIITOOL=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_TFTP=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENU_MANAGEMENT=y
+CONFIG_CMD_MENUTREE=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_CRC=y
+CONFIG_CMD_CRC_CMP=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_MM=y
+CONFIG_CMD_CLK=y
+CONFIG_CMD_DETECT=y
+CONFIG_CMD_FLASH=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_LED=y
+CONFIG_CMD_LED_MODE=y
+CONFIG_CMD_POWEROFF=y
+CONFIG_CMD_USBGADGET=y
+CONFIG_CMD_WD=y
+CONFIG_CMD_BAREBOX_UPDATE=y
+CONFIG_CMD_OF_DIFF=y
+CONFIG_CMD_OF_NODE=y
+CONFIG_CMD_OF_PROPERTY=y
+CONFIG_CMD_OF_OVERLAY=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_STATE=y
+CONFIG_CMD_UART_CONSOLE=y
+CONFIG_CMD_ETHADDR_MATCH=y
+CONFIG_NET=y
+CONFIG_NET_NETCONSOLE=y
+CONFIG_NET_FASTBOOT=y
+CONFIG_OF_BAREBOX_DRIVERS=y
+CONFIG_AIODEV=y
+CONFIG_STM32_ADC=y
+CONFIG_DRIVER_SERIAL_STM32=y
+CONFIG_DRIVER_NET_DESIGNWARE_EQOS=y
+CONFIG_DRIVER_NET_DESIGNWARE_STM32=y
+CONFIG_AT803X_PHY=y
+CONFIG_MICREL_PHY=y
+CONFIG_REALTEK_PHY=y
+# CONFIG_SPI is not set
+CONFIG_I2C=y
+CONFIG_I2C_STM32=y
+CONFIG_USB_HOST=y
+CONFIG_USB_DWC2_HOST=y
+CONFIG_USB_DWC2_GADGET=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DFU=y
+CONFIG_USB_GADGET_SERIAL=y
+CONFIG_USB_GADGET_FASTBOOT=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_MMC_BOOT_PARTITIONS=y
+CONFIG_MCI_STM32_SDMMC2=y
+CONFIG_MFD_STPMIC1=y
+CONFIG_MFD_STM32_TIMERS=y
+CONFIG_STATE_DRV=y
+CONFIG_XSECTION=y
+CONFIG_BOOTMATRIX=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_LED_PWM=y
+CONFIG_LED_GPIO_OF=y
+CONFIG_LED_TRIGGERS=y
+CONFIG_EEPROM_AT24=y
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_INPUT_SPECIALKEYS=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_POLLER=y
+CONFIG_STM32_IWDG_WATCHDOG=y
+CONFIG_STPMIC1_WATCHDOG=y
+CONFIG_PWM=y
+CONFIG_PWM_STM32=y
+CONFIG_HWRNG=y
+CONFIG_HWRNG_STM32=y
+CONFIG_GPIO_DESIGNWARE=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_STM32_BSEC=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED=y
+CONFIG_REGULATOR_STM32_PWR=y
+CONFIG_REGULATOR_STM32_VREFBUF=y
+CONFIG_REGULATOR_STPMIC1=y
+CONFIG_REMOTEPROC=y
+CONFIG_STM32_REMOTEPROC=y
+CONFIG_RESET_STM32=y
+CONFIG_GENERIC_PHY=y
+CONFIG_PHY_STM32_USBPHYC=y
+CONFIG_SYSCON_REBOOT_MODE=y
+CONFIG_FS_EXT4=y
+CONFIG_FS_TFTP=y
+CONFIG_FS_NFS=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_WRITE=y
+CONFIG_FS_FAT_LFN=y
+CONFIG_FS_PSTORE=y
+CONFIG_FS_PSTORE_CONSOLE=y
+CONFIG_FS_PSTORE_RAMOOPS=y
+CONFIG_FS_SQUASHFS=y
+CONFIG_FS_RATP=y
+CONFIG_ZLIB=y
+CONFIG_CRC8=y
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index a637869fb67..949ca15cf4b 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -113,6 +113,7 @@ lwl-$(CONFIG_MACH_SOLIDRUN_MICROSOM) += imx6dl-hummingboard.dtb.o imx6q-hummingb
 				imx6q-h100.dtb.o
 lwl-$(CONFIG_MACH_SKOV_IMX6) += imx6dl-skov-imx6.dtb.o imx6q-skov-imx6.dtb.o
 lwl-$(CONFIG_MACH_SKOV_ARM9CPU) += at91-skov-arm9cpu.dtb.o
+lwl-$(CONFIG_MACH_STM32MP151_CC100) += stm32mp151-cc100.dtb.o
 lwl-$(CONFIG_MACH_SEEED_ODYSSEY) += stm32mp157c-odyssey.dtb.o
 lwl-$(CONFIG_MACH_STM32MP15XX_DKX) += stm32mp157c-dk2.dtb.o stm32mp157a-dk1.dtb.o
 lwl-$(CONFIG_MACH_LXA_MC1) += stm32mp157c-lxa-mc1.dtb.o
diff --git a/arch/arm/dts/bootchooser.dtsi b/arch/arm/dts/bootchooser.dtsi
new file mode 100644
index 00000000000..14566487c33
--- /dev/null
+++ b/arch/arm/dts/bootchooser.dtsi
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/ {
+	bootstate: bootstate {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		magic = <0x3f45620e>;
+		compatible = "barebox,state";
+		backend-type = "raw";
+		backend = <&backend_state_eeprom>;
+		backend-storage-type = "direct";
+		backend-stridesize = <0x40>;
+
+		rootfs.1 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			remaining_attempts@0 {
+				reg = <0x0 0x4>;
+				type = "uint32";
+				default = <3>;
+			};
+
+			priority@4 {
+				reg = <0x4 0x4>;
+				type = "uint32";
+				default = <20>;
+			};
+		};
+
+		rootfs.2 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			remaining_attempts@8 {
+				reg = <0x8 0x4>;
+				type = "uint32";
+				default = <3>;
+			};
+
+			priority@10 {
+				reg = <0xC 0x4>;
+				type = "uint32";
+				default = <10>;
+			};
+		};
+
+		last_chosen@10 {
+			reg = <0x10 0x4>;
+			type = "uint32";
+		};
+
+		device_setup@14 {
+			reg = <0x14 0x4>;
+			type = "uint32";
+		};
+	};
+};
diff --git a/arch/arm/dts/eepromparts.dtsi b/arch/arm/dts/eepromparts.dtsi
new file mode 100644
index 00000000000..c7718e1b5ad
--- /dev/null
+++ b/arch/arm/dts/eepromparts.dtsi
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&eeprom {
+	partitions: partitions {
+		compatible = "fixed-partitions";
+		#size-cells = <1>;
+		#address-cells = <1>;
+
+		backend_state_eeprom: state@2100 {
+			reg = <0x2100 0x120>;
+			label = "state-eeprom";
+		};
+
+		boot_mode_id: boot-mode-id@0 {
+			reg = <0x0 0x1>;
+			label = "boot_mode_id";
+		};
+
+		boot_mode_id_ext: boot-mode-id_ext@0102 {
+			reg = <0x0102 0x1>;
+			label = "boot_mode_id_ext";
+		};
+
+		blidx: blidx@1F7 {
+			reg = <0x1F7 0x1>;
+			label = "blidx";
+		};
+
+		devconf: devconf@1FE {
+			reg = <0x1FE 0x2>;
+			label = "devconf";
+		};
+
+		ethaddr1: ethaddr1@200 {
+			reg = <0x200 0x6>;
+			label = "ethaddr1";
+		};
+
+		ethaddr2: ethaddr2@206 {
+			label = "ethaddr2";
+			reg = <0x206 0x6>;
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp151-cc100-pinctrl.dtsi b/arch/arm/dts/stm32mp151-cc100-pinctrl.dtsi
new file mode 100644
index 00000000000..c96c67e864b
--- /dev/null
+++ b/arch/arm/dts/stm32mp151-cc100-pinctrl.dtsi
@@ -0,0 +1,133 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+&pinctrl {
+	uart4_pins_a: uart4_a-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 11, AF6)>; /* UART4_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 2, AF8)>; /* UART4_RX */
+			bias-disable;
+		};
+	};
+
+	i2c2_pins_a: i2c2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 4, AF4)>,  /* I2C2_SCL */
+					 <STM32_PINMUX('G', 15, AF4)>; /* I2C2_SDA */
+			bias-pull-up;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c4_pins_a: i2c4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 11, AF4)>, /* I2C4_SCL */
+					 <STM32_PINMUX('H', 12, AF4)>; /* I2C4_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	eth1_pins_a: eth1_a-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 1, AF11)>, /* ETH1_REF_CLK */
+					 <STM32_PINMUX('B', 13, AF11)>, /* ETH1_TXD1 */
+					 <STM32_PINMUX('G', 13, AF11)>; /* ETH1_TXD0 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 7, AF11)>, /* ETH1_CRS_DV */
+					 <STM32_PINMUX('C', 4, AF11)>, /* ETH1_RXD0 */
+					 <STM32_PINMUX('C', 5, AF11)>; /* ETH1_RXD1 */
+			bias-disable;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('B', 11, AF11)>; /* ETH1_TX_EN */
+		};
+	};
+
+	sdmmc1_b4_pins_a: sdmmc1-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C',  8, AF12)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C',  9, AF12)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E',  6,  AF8)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, AF12)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('D',  2, AF12)>; /* SDMMC1_CMD */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 12, AF12)>; /* SDMMC1_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('I', 5, GPIO)>; 	/* SDMMC1_NCD */
+			slew-rate = <0>;
+			bias-disable;
+			input-enable;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('G', 10, GPIO)>; /* SDMMC1_LED */
+			slew-rate = <0>;
+			drive-push-pull;
+			bias-disable;
+			output-low;
+		};
+	};
+
+	sdmmc2_b8_pins: sdmmc2-b8-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 14, AF9)>,  /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, AF9)>,  /* SDMMC2_D1 */
+				 <STM32_PINMUX('B',  3, AF9)>,  /* SDMMC2_D2 */
+				 <STM32_PINMUX('B',  4, AF9)>,  /* SDMMC2_D3 */
+				 <STM32_PINMUX('E',  4, AF9)>,  /* SDMMC2_D4 */
+				 <STM32_PINMUX('B',  9, AF10)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E',  5, AF9)>,  /* SDMMC2_D6 */
+				 <STM32_PINMUX('D',  3, AF9)>,  /* SDMMC2_D7 */
+				 <STM32_PINMUX('G',  6, AF10)>; /* SDMMC2_CMD */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF9)>; /* SDMMC2_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	bas_pins: bas-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('J',  6, GPIO)>,  /* BAS_RUN */
+				 <STM32_PINMUX('A',  8, GPIO)>,  /* BAS_STOP */
+				 <STM32_PINMUX('I', 11, GPIO)>,  /* BAS_RESET */
+				 <STM32_PINMUX('Z',  4, GPIO)>;  /* BAS_RST */
+		};
+	};
+
+	led_pins: led-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B',  0, GPIO)>,  /* LED_RUN_G */
+				 <STM32_PINMUX('B', 12, GPIO)>,  /* LED_RUN_R */
+				 <STM32_PINMUX('A', 14, GPIO)>,  /* LED_SYS_G */
+				 <STM32_PINMUX('A', 13, GPIO)>,  /* LED_SYS_R */
+				 <STM32_PINMUX('J',  1, GPIO)>,  /* LED_USR_G */
+				 <STM32_PINMUX('I', 10, GPIO)>;  /* LED_USR_R */
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp151-cc100.dts b/arch/arm/dts/stm32mp151-cc100.dts
new file mode 100644
index 00000000000..b4f3b789d9d
--- /dev/null
+++ b/arch/arm/dts/stm32mp151-cc100.dts
@@ -0,0 +1,403 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/dts-v1/;
+
+#include <arm/stm32mp151.dtsi>
+#include "stm32mp151.dtsi"
+#include "stm32mp151-cc100-pinctrl.dtsi"
+#include <arm/stm32mp15xxaa-pinctrl.dtsi>
+#include <arm/stm32mp15xc.dtsi>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/mfd/st,stpmic1.h>
+#include "bootchooser.dtsi"
+
+/ {
+	model = "CC100-751-9301";
+	compatible = "wago,stm32mp151-cc100-751_9301", "wago,stm32mp151-cc100", "st,stm32mp151";
+	board-variant = "cc100";
+
+	aliases {
+		ethernet0 = &ethernet0;
+		mdio-gpio0 = &bitbang_mdio0;
+		serial0 = &uart4;
+		bootstate = &bootstate;
+		xsection = &xsection;
+		bootmatrix = &bootmatrix;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	xsection: xsection {
+		compatible = "xsection";
+		status = "okay";
+
+		boot_mode_id = <&boot_mode_id>;
+		boot_mode_id_ext = <&boot_mode_id_ext>;
+		devconf = <&devconf>;
+		ethaddr1 = <&ethaddr1>;
+		ethaddr2 = <&ethaddr2>;
+		blidx = <&blidx>;
+	};
+
+	bitbang_mdio0: gpio_mdio {
+		compatible = "virtual,mdio-gpio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		gpios = <
+			&gpioc 1 0	/* 0: mdc  */
+			&gpioa 2 0	/* 1: mdio */
+		>;
+		status = "disabled";
+	};
+
+	bootmatrix: bootmatrix {
+		compatible = "bootmatrix";
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&bas_pins>;
+
+		/* seconds for factory reset or setup-fw startup */
+		rst-timeout-secs = <7>;
+
+		run:   run   { gpios = <&gpioj  6 GPIO_ACTIVE_LOW>; };
+		stop:  stop  { gpios = <&gpioa  8 GPIO_ACTIVE_LOW>; };
+		reset: reset { gpios = <&gpioi 11 GPIO_ACTIVE_LOW>; };
+		rst:   rst   { gpios = <&gpioz  4 GPIO_ACTIVE_LOW>; };
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&led_pins>;
+
+		u1-green@0 {
+			label = "u1-green";
+			gpios = <&gpioj 1 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+
+		u1-red@1 {
+			label = "u1-red";
+			gpios = <&gpioi 10 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+
+		sys-green@2 {
+			label = "sys-green";
+			gpios = <&gpioa 14 GPIO_ACTIVE_LOW>;
+			linux,default-trigger = "none";
+		};
+
+		sys-red@3 {
+			label = "sys-red";
+			gpios = <&gpioa 13 GPIO_ACTIVE_LOW>;
+			linux,default-trigger = "none";
+		};
+
+		run-green@4 {
+			label = "run-green";
+			gpios = <&gpiob 0 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+
+		run-red@5 {
+			label = "run-red";
+			gpios = <&gpiob 12 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+	};
+
+};
+
+&i2c2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	status = "okay";
+	secure-status = "okay";
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	clock-frequency = <100000>;
+
+	rtc_r2221t: rtc@32 {
+		compatible = "ricoh,r2221tl";
+		reg = <0x32>;
+
+		interrupt-parent = <&gpiob>;
+		interrupts = <8 IRQ_TYPE_LEVEL_LOW>;
+	};
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	status = "okay";
+	secure-status = "okay";
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	clock-frequency = <100000>;
+
+	eeprom: m24c512@54 {
+		status = "okay";
+		compatible = "st,24c512", "at24";
+		reg = <0x54>;
+		pagesize = <128>;
+	};
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&gpioa 0 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			ldo1-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo6-supply = <&v3v3>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			v1v8_audio: ldo1 {
+				regulator-name = "v1v8_audio";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				regulator-always-on;
+				interrupts = <IT_CURLIM_LDO1 0>;
+			};
+
+			v3v3_hdmi: ldo2 {
+				regulator-name = "v3v3_hdmi";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+
+				regulator-always-on;
+				interrupts = <IT_CURLIM_LDO2 0>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <750000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				interrupts = <IT_CURLIM_LDO4 0>;
+			};
+
+			vdda: ldo5 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO5 0>;
+				regulator-boot-on;
+			};
+
+			v1v2_hdmi: ldo6 {
+				regulator-name = "v1v2_hdmi";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				interrupts = <IT_CURLIM_LDO6 0>;
+			};
+
+			vref_ddr: vref_ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+				interrupts = <IT_OCP_BOOST 0>;
+			};
+
+			vbus_otg: pwr_sw1 {
+				regulator-name = "vbus_otg";
+				interrupts = <IT_OCP_OTG 0>;
+			};
+
+			vbus_sw: pwr_sw2 {
+				regulator-name = "vbus_sw";
+				interrupts = <IT_OCP_SWOUT 0>;
+				regulator-active-discharge;
+			};
+		};
+
+		onkey {
+			compatible = "st,stpmic1-onkey";
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
+			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
+		};
+
+		watchdog {
+			compatible = "st,stpmic1-wdt";
+			status = "disabled";
+		};
+	};
+
+};
+
+#include "eepromparts.dtsi"
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4_pins_a>;
+	status = "disabled";
+};
+
+&sdmmc1 {
+	status = "okay";
+
+	bus-width = <4>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc1_b4_pins_a>;
+	cd-gpios = <&gpioi 5 GPIO_ACTIVE_LOW>;
+	cd-inverted;
+	disable-wp;
+	st,neg-edge;
+};
+
+&sdmmc2 {
+	status = "okay";
+
+	bus-width = <8>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc2_b8_pins>;
+	non-removable;
+};
+
+&gpiog {
+         led-mmc {
+                 gpio-hog;
+                 gpios = <10 GPIO_ACTIVE_HIGH>;
+                 output-low;
+        };
+};
+
+&ethernet0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&eth1_pins_a>;
+	phy-mode = "rmii";
+	phy-handle = <&ethphy0>;
+	phy-reset-gpios = <&gpiog 7 GPIO_ACTIVE_LOW>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@0 {
+			compatible = "micrel,ksz8863";
+			device_type = "ethernet-phy";
+			reg = <0>;
+		};
+	};
+};
+
+&bitbang_mdio0 {
+	ksz8863_switch: switch@0 {
+		compatible = "micrel,ksz8863";
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg = <0>;
+		dsa,member = <0 0>;
+		dsa,enable-on-boot;
+
+		ksz,reset-switch;
+
+		phy-mode = "rmii";
+
+		interrupt-parent = <&gpiog>;
+		interrupts = <12 IRQ_TYPE_LEVEL_LOW>;
+
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <2>;
+				label = "ethX1";
+				phy-mode = "rmii";
+				phy-pwrdown;
+			};
+
+			port@1 {
+				reg = <1>;
+				label = "ethX2";
+				phy-mode = "rmii";
+				phy-pwrdown;
+			};
+
+			port@2 {
+				reg = <3>;
+				label = "cpu";
+				phy-mode = "rmii";
+				ethernet = <&ethernet0>;
+				fixed-link {
+					speed = <100>;
+					full-duplex;
+				};
+			};
+		};
+	};
+
+};
+
+&iwdg2 {
+	status = "okay";
+};
diff --git a/arch/arm/mach-stm32mp/Kconfig b/arch/arm/mach-stm32mp/Kconfig
index 95d3dc510d1..8bab9df5063 100644
--- a/arch/arm/mach-stm32mp/Kconfig
+++ b/arch/arm/mach-stm32mp/Kconfig
@@ -31,4 +31,9 @@ config MACH_STM32MP15X_EV1
 	  as SSBL on any STM32MP15X-EVAL platform, like the
 	  STM32MP157C-EV1
 
+config MACH_STM32MP151_CC100
+	select ARCH_STM32MP157
+	bool "STM32MP151-CC100 PLC board"
+	help
+	  todo
 endif
diff --git a/arch/arm/mach-stm32mp/init.c b/arch/arm/mach-stm32mp/init.c
index 01961ae4562..017450a69c2 100644
--- a/arch/arm/mach-stm32mp/init.c
+++ b/arch/arm/mach-stm32mp/init.c
@@ -76,8 +76,12 @@ static void setup_boot_mode(void)
 		src = BOOTSOURCE_USB;
 		break;
 	case STM32MP_BOOT_FLASH_SD:
+		src = BOOTSOURCE_MMC;
+		instance = 0;
+		break;
 	case STM32MP_BOOT_FLASH_EMMC:
 		src = BOOTSOURCE_MMC;
+		instance = 1;
 		break;
 	case STM32MP_BOOT_FLASH_NAND:
 		src = BOOTSOURCE_NAND;
diff --git a/commands/Kconfig b/commands/Kconfig
index 5ae3cb3dd14..019e11510a7 100644
--- a/commands/Kconfig
+++ b/commands/Kconfig
@@ -1852,6 +1852,13 @@ config CMD_LED
 
 	  Without arguments the available LEDs are listed.
 
+config CMD_LED_MODE
+	bool
+	depends on LED
+	prompt "led-mode command"
+	help
+	  Set LED's to mode "static" or "moving"
+
 config CMD_NAND
 	tristate
 	default y
@@ -2232,6 +2239,30 @@ config CMD_UBSAN
 	  This is a test command for the undefined behavior sanitizer.
 	  It triggers various undefined behavior, and detect it.
 
+config CMD_UART_CONSOLE
+	tristate
+	prompt "uart_console"
+	help
+	  uart_console - activate uart as console
+
+	  Usage: uart_console [-e] [NUM]
+
+	  Options:
+		  -e		enable uart<NUM> as console
+
+config CMD_ETHADDR_MATCH
+	bool
+	prompt "ethaddr_match"
+	help
+	  ethaddr_match - Match a given pattern to configured ethaddr of an
+	  ethernet interface
+
+	  Usage: ethaddr_match [-i intf] [-p pattern]
+
+	  Options:
+		  -i		network interface e.g. eth0
+		  -p		pattern to match against ethaddr
+
 # end Miscellaneous commands
 endmenu
 
diff --git a/commands/Makefile b/commands/Makefile
index 447349fd157..38832f1ef5d 100644
--- a/commands/Makefile
+++ b/commands/Makefile
@@ -130,5 +130,8 @@ obj-$(CONFIG_CMD_SEED)		+= seed.o
 obj-$(CONFIG_CMD_IP_ROUTE_GET)  += ip-route-get.o
 obj-$(CONFIG_CMD_BTHREAD)	+= bthread.o
 obj-$(CONFIG_CMD_UBSAN)		+= ubsan.o
+obj-$(CONFIG_CMD_UART_CONSOLE)	+= uart_console.o
+obj-$(CONFIG_CMD_ETHADDR_MATCH) += ethaddr_match.o
+obj-$(CONFIG_CMD_LED_MODE) 	+= led_mode.o
 
 UBSAN_SANITIZE_ubsan.o := y
diff --git a/commands/ethaddr_match.c b/commands/ethaddr_match.c
new file mode 100644
index 00000000000..5afbe5c78a9
--- /dev/null
+++ b/commands/ethaddr_match.c
@@ -0,0 +1,69 @@
+/*
+ * ethaddr_match.c - match a given ethaddr pattern command support
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <command.h>
+#include <getopt.h>
+#include <net.h>
+
+static int do_ethaddr_match(int argc, char *argv[])
+{
+	int opt;
+	struct eth_device *edev;
+	char *ethname = NULL, *pattern = NULL;
+	char ethaddr_str[sizeof("xx:xx:xx:xx:xx:xx")];
+
+	while ((opt = getopt(argc, argv, "i:p:")) > 0) {
+		switch (opt) {
+		case 'i':
+			ethname = optarg;
+			break;
+		case 'p':
+			pattern = optarg;
+			break;
+		}
+	}
+
+	if (!ethname || !pattern)
+		return COMMAND_ERROR_USAGE;
+
+	edev = eth_get_byname(ethname);
+	if (!edev)
+		return -ENODEV;
+
+	ethaddr_to_string(edev->ethaddr, ethaddr_str);
+	if (strstr(ethaddr_str, pattern))
+		return COMMAND_SUCCESS;
+
+	return COMMAND_ERROR;
+}
+
+BAREBOX_CMD_HELP_START(ethaddr_match)
+BAREBOX_CMD_HELP_TEXT("Options:")
+BAREBOX_CMD_HELP_OPT("-i <intf>",           "network interface e.g. eth0\n")
+BAREBOX_CMD_HELP_OPT("-p <match_pattern>",  "pattern to match to ethaddr of"
+								" <intf>\n")
+BAREBOX_CMD_HELP_END
+
+BAREBOX_CMD_START(ethaddr_match)
+	.cmd		= do_ethaddr_match,
+	BAREBOX_CMD_DESC("Match a given pattern to configured ethaddr of an"
+							"ethernet interface")
+	BAREBOX_CMD_OPTS("[-ip]")
+	BAREBOX_CMD_GROUP(CMD_GRP_MISC)
+	BAREBOX_CMD_HELP(cmd_ethaddr_match_help)
+BAREBOX_CMD_END
diff --git a/commands/led_mode.c b/commands/led_mode.c
new file mode 100644
index 00000000000..2b945099d76
--- /dev/null
+++ b/commands/led_mode.c
@@ -0,0 +1,177 @@
+/*
+ * led_mode.c - command to set all registered leds to a specific mode
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <common.h>
+#include <led.h>
+#include <led_mode.h>
+#include <command.h>
+#include <getopt.h>
+#include <errno.h>
+
+#define OVERWRITE_LED "overwrite"
+
+enum led_mode {
+	STATIC = 0,
+	MOVING,
+	INVALID_MODE,
+};
+
+int led_mode_static(char *color, bool state)
+{
+	struct led *led;
+	int i;
+
+	if (strcmp(color, "green") && strcmp(color, "red") &&
+							strcmp(color, "yellow"))
+		return -EINVAL;
+
+	led = led_by_number(0);
+	if (!led)
+		return -ENODEV;
+
+	i = 0;
+	while ((led = led_by_number(i))) {
+		if (strcmp(led->name, OVERWRITE_LED)) {
+			if (strstr(led->name, color))
+				state ? led_set(led, led->max_value) :
+								led_set(led, 0);
+			else if (!strcmp(color, "yellow"))
+				state ? led_set(led, led->max_value) :
+								led_set(led, 0);
+		}
+		i++;
+	}
+
+	return 0;
+}
+
+int led_mode_moving(char *color, unsigned int duration_ms, bool turn_off_anc)
+{
+	struct led *led, *last_led;
+	int i;
+
+	if (strcmp(color, "green") && strcmp(color, "red"))
+		return -EINVAL;
+
+	led = led_by_number(0);
+	if (!led)
+		return -ENODEV;
+
+	/* switch all leds off */
+	led_mode_static("yellow", false);
+
+	i = 0;
+	last_led = NULL;
+	while ((led = led_by_number(i++))) {
+		if (strcmp(led->name, OVERWRITE_LED)) {
+			if (strstr(led->name, color)) {
+				if (last_led && turn_off_anc)
+					led_set(last_led, 0);
+
+				led_set(led, led->max_value);
+				last_led = led;
+				mdelay(duration_ms);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int do_led_mode(int argc, char *argv[])
+{
+	char *color = "none";
+	enum led_mode mode = INVALID_MODE;
+	bool state = false, turn_off_anc = true;
+	unsigned int duration_ms = 30;
+	int opt, ret = 0;
+
+	while ((opt = getopt(argc, argv, "smc:v::d::t")) > 0) {
+		switch (opt) {
+		case 's':
+			mode = STATIC;
+			break;
+		case 'm':
+			mode = MOVING;
+			break;
+		case 'c':
+			color = optarg;
+			break;
+		case 'v':
+			if (!strcmp(optarg, "on"))
+				state = true;
+			else
+				state = false;
+			break;
+		case 'd':
+			duration_ms = simple_strtoul(optarg, NULL, 0);
+			break;
+		case 't':
+			turn_off_anc = false;
+			break;
+
+		default:
+			ret = COMMAND_ERROR_USAGE;
+			goto out;
+		}
+	}
+
+	if (argc == 1) {
+		ret = COMMAND_ERROR_USAGE;
+		goto out;
+	}
+
+	switch (mode) {
+	case STATIC:
+		ret = led_mode_static(color, state);
+		break;
+	case MOVING:
+		ret = led_mode_moving(color, duration_ms, turn_off_anc);
+		break;
+	default:
+		ret = COMMAND_ERROR_USAGE;
+	}
+
+out:
+	return ret;
+}
+
+BAREBOX_CMD_HELP_START(led_mode)
+BAREBOX_CMD_HELP_TEXT("Set all registered leds to a specific mode. Supported ")
+BAREBOX_CMD_HELP_TEXT("modes are: static and moving. In static mode all leds ")
+BAREBOX_CMD_HELP_TEXT("are turned on/off at once.")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("In moving mode all leds are flashing with a defined ")
+BAREBOX_CMD_HELP_TEXT("duration.")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("LEDs are set by the order they where registered. ")
+BAREBOX_CMD_HELP_TEXT("To see the currently configured order call ")
+BAREBOX_CMD_HELP_TEXT("cmd: <led> without args.")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("Options:")
+BAREBOX_CMD_HELP_OPT ("-s -c <green|red|yellow> -v <on|off>", "set all leds to static state")
+BAREBOX_CMD_HELP_OPT ("-m -c <green|red> [ -d <duration_ms> ] [ -t ]", "move the leds with optional duration time. Default 30ms. The optional option -t is used to not tur off the ancestor led")
+BAREBOX_CMD_HELP_END
+
+BAREBOX_CMD_START(led_mode)
+	.cmd		= do_led_mode,
+	BAREBOX_CMD_DESC("set leds to specific mode")
+	BAREBOX_CMD_OPTS("MODE COLOR STATE|DURATION")
+	BAREBOX_CMD_GROUP(CMD_GRP_HWMANIP)
+	BAREBOX_CMD_HELP(cmd_led_mode_help)
+BAREBOX_CMD_END
diff --git a/commands/miitool.c b/commands/miitool.c
index 47494f50897..74da0dfa3b1 100644
--- a/commands/miitool.c
+++ b/commands/miitool.c
@@ -21,6 +21,7 @@
 #include <fs.h>
 #include <fcntl.h>
 #include <getopt.h>
+#include <environment.h>
 #include <linux/stat.h>
 #include <xfuncs.h>
 #include <net.h>
@@ -257,13 +258,139 @@ enum miitool_operations {
 	MIITOOL_NOOP,
 	MIITOOL_SHOW,
 	MIITOOL_REGISTER,
+	MIITOOL_MDIO_READ,
+	MIITOOL_MDIO_WRITE,
 };
 
+static int miitool_parse(const char *str, int *bus, struct mii_bus **mii,
+			 int *addr, int *reg)
+{
+	char *endp;
+
+	if (!str || !*str)
+		return COMMAND_ERROR_USAGE;
+
+	if (!bus || !mii)
+		return COMMAND_ERROR;
+
+	*bus = simple_strtoul(str, &endp, 0);
+
+	*mii = mdiobus_get_bus(*bus);
+	if (!*mii) {
+		printf("Can't find MDIO bus #%d\n", *bus);
+		return COMMAND_ERROR;
+	}
+
+	if (!addr)
+		return COMMAND_SUCCESS;
+
+	if (*endp != ':') {
+		printf("No colon between bus and address\n");
+		return COMMAND_ERROR_USAGE;
+	}
+
+	endp++;
+	*addr = simple_strtoul(endp, &endp, 0);
+
+	if (*addr >= PHY_MAX_ADDR) {
+		printf("Address out of range (max %d)\n", PHY_MAX_ADDR - 1);
+		return COMMAND_ERROR_USAGE;
+	}
+
+	if (!reg)
+		return COMMAND_SUCCESS;
+
+	if (*endp != ':') {
+		printf("No colon address and register\n");
+		return COMMAND_ERROR_USAGE;
+	}
+
+	endp++;
+	*reg = simple_strtoul(endp, &endp, 0);
+
+	if (*reg > U8_MAX) {
+		printf("Register number out of range (max %d)\n", U8_MAX);
+		return COMMAND_ERROR_USAGE;
+	}
+
+	return 0;
+}
+
+static int miitool_mdio_write(const char *str, const char *variable, int ext)
+{
+	int ret;
+	struct mii_bus *mii;
+	int bus, addr, reg;
+	unsigned long val;
+
+	if (!variable || !*variable)
+		return COMMAND_ERROR_USAGE;
+
+	ret = miitool_parse(str, &bus, &mii, &addr, &reg);
+	if (ret)
+		return ret;
+
+	ret = getenv_ul(variable, &val);
+	if (ret)
+		return COMMAND_ERROR_USAGE;
+
+	if (val > U16_MAX) {
+		printf("Value out auf range (max %d 0x%04X)\n", U16_MAX,
+		       U16_MAX);
+		return COMMAND_ERROR;
+	}
+
+	if (ext) {
+		mdiobus_write(mii, addr, MII_MMD_CTRL, MII_MMD_CTRL_DEVAD_MASK);
+		mdiobus_write(mii, addr, MII_MMD_DATA, reg);
+		mdiobus_write(mii, addr, MII_MMD_CTRL, MII_MMD_CTRL_DEVAD_MASK |
+						MII_MMD_CTRL_NOINCR);
+		ret = mdiobus_write(mii, addr, MII_MMD_DATA, val);
+	} else
+		ret = mdiobus_write(mii, addr, reg, val);
+
+	return (!ret) ? ret : COMMAND_ERROR_USAGE;
+}
+
+static int miitool_mdio_read(const char *str, const char *variable, int ext)
+{
+	int ret;
+	struct mii_bus *mii;
+	int bus, addr, reg;
+	char buf[20] = {0};
+
+	if (!variable || !*variable)
+		return COMMAND_ERROR_USAGE;
+
+	ret = miitool_parse(str, &bus, &mii, &addr, &reg);
+	if (ret)
+		return ret;
+
+	if (ext) {
+		mdiobus_write(mii, addr, MII_MMD_CTRL, MII_MMD_CTRL_DEVAD_MASK);
+		mdiobus_write(mii, addr, MII_MMD_DATA, reg);
+		mdiobus_write(mii, addr, MII_MMD_CTRL, MII_MMD_CTRL_DEVAD_MASK |
+							MII_MMD_CTRL_NOINCR);
+		ret = mdiobus_read(mii, addr, MII_MMD_DATA);
+	} else
+		ret = mdiobus_read(mii, addr, reg);
+
+	if (ret < 0)
+		return ret;
+
+	snprintf(buf, sizeof(buf), "%d", (u16)ret);
+
+	ret = setenv(variable, strim(buf));
+
+	return (!ret) ? ret : COMMAND_ERROR_USAGE;
+}
+
 static int do_miitool(int argc, char *argv[])
 {
 	char *phydevname = NULL;
 	char *regstr = NULL;
-	char *endp;
+	char *variable = NULL;
+	int ext = 0;
 	struct mii_bus *mii;
 	int opt, ret;
 	int verbose = 0;
@@ -271,8 +398,11 @@ static int do_miitool(int argc, char *argv[])
 	enum miitool_operations action = MIITOOL_NOOP;
 	int addr, bus;
 
-	while ((opt = getopt(argc, argv, "vs:r:")) > 0) {
+	while ((opt = getopt(argc, argv, "evs:r:w:x:p:")) > 0) {
 		switch (opt) {
+		case 'e':
+			ext = 1;
+			break;
 		case 's':
 			action = MIITOOL_SHOW;
 			phydevname = xstrdup(optarg);
@@ -284,42 +414,50 @@ static int do_miitool(int argc, char *argv[])
 		case 'v':
 			verbose++;
 			break;
+		case 'p':
+			variable = optarg;
+			break;
+		case 'w':
+			action = MIITOOL_MDIO_WRITE;
+			regstr = optarg;
+			break;
+		case 'x':
+			action = MIITOOL_MDIO_READ;
+			regstr = optarg;
+			break;
 		default:
 			ret = COMMAND_ERROR_USAGE;
-			goto free_phydevname;
+			goto out;
 		}
 	}
 
 	switch (action) {
 	case MIITOOL_REGISTER:
-		bus = simple_strtoul(regstr, &endp, 0);
-		if (*endp != ':') {
-			printf("No colon between bus and address\n");
-			return COMMAND_ERROR_USAGE;
-		}
-		endp++;
-		addr = simple_strtoul(endp, NULL, 0);
-
-		if (addr >= PHY_MAX_ADDR)
-			printf("Address out of range (max %d)\n", PHY_MAX_ADDR - 1);
-
-		mii = mdiobus_get_bus(bus);
-		if (!mii) {
-			printf("Can't find MDIO bus #%d\n", bus);
-			ret = COMMAND_ERROR;
-			goto free_phydevname;
-		}
+		ret = miitool_parse(regstr, &bus, &mii, &addr, NULL);
+		if (ret)
+			goto out;
 
 		phydev = phy_device_create(mii, addr, -1);
+
 		ret = phy_register_device(phydev);
 		if (ret) {
 			printf("failed to register phy %s: %s\n",
 				dev_name(&phydev->dev), strerror(-ret));
-			goto free_phydevname;
+			goto out;
 		} else {
 			printf("registered phy %s\n", dev_name(&phydev->dev));
 		}
 		break;
+	case MIITOOL_MDIO_WRITE:
+		ret = miitool_mdio_write(regstr, variable, ext);
+		if (ret)
+			goto out;
+		break;
+	case MIITOOL_MDIO_READ:
+		ret = miitool_mdio_read(regstr, variable, ext);
+		if (ret)
+			goto out;
+		break;
 	default:
 	case MIITOOL_SHOW:
 		for_each_mii_bus(mii) {
@@ -333,7 +471,7 @@ static int do_miitool(int argc, char *argv[])
 
 	ret = COMMAND_SUCCESS;
 
-free_phydevname:
+out:
 	free(phydevname);
 	return ret;
 }
@@ -343,17 +481,21 @@ BAREBOX_CMD_HELP_TEXT("This utility checks or sets the status of a network inter
 BAREBOX_CMD_HELP_TEXT("Media Independent Interface (MII) unit as well as allowing to")
 BAREBOX_CMD_HELP_TEXT("register dummy PHY devices for raw MDIO access. Most fast ethernet")
 BAREBOX_CMD_HELP_TEXT("adapters use an MII to autonegotiate link speed and duplex setting.")
+BAREBOX_CMD_HELP_TEXT("Furthermore it allows to acces to MDIO bus directly")
 BAREBOX_CMD_HELP_TEXT("")
 BAREBOX_CMD_HELP_TEXT("Options:")
 BAREBOX_CMD_HELP_OPT("-v", "increase verbosity")
 BAREBOX_CMD_HELP_OPT("-s <devpath/devname>", "show PHY status (not providing PHY prints status of all)")
-BAREBOX_CMD_HELP_OPT("-r <busno>:<adr>", "register a PHY")
+BAREBOX_CMD_HELP_OPT("-r <busno>:<addr>", "register a PHY")
+BAREBOX_CMD_HELP_OPT("-w <busno>:<addr>:<reg> -p variable", "read value from variable and writes it to MDIO bus")
+BAREBOX_CMD_HELP_OPT("-x <busno>:<addr>:<reg> -p variable", "read value from MDIO bus and writes it to variable")
+BAREBOX_CMD_HELP_OPT("-e", "enable (once) extended register read/write")
 BAREBOX_CMD_HELP_END
 
 BAREBOX_CMD_START(miitool)
 	.cmd		= do_miitool,
-	BAREBOX_CMD_DESC("view media-independent interface status")
-	BAREBOX_CMD_OPTS("[-vsr]")
+	BAREBOX_CMD_DESC("media-independent interface access")
+	BAREBOX_CMD_OPTS("[-evsrwxp]")
 	BAREBOX_CMD_GROUP(CMD_GRP_NET)
 	BAREBOX_CMD_HELP(cmd_miitool_help)
 BAREBOX_CMD_END
diff --git a/commands/uart_console.c b/commands/uart_console.c
new file mode 100644
index 00000000000..ea752866316
--- /dev/null
+++ b/commands/uart_console.c
@@ -0,0 +1,63 @@
+/*
+ * uart_console.c - command to activate a dedicated uart
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <common.h>
+#include <of.h>
+#include <of_address.h>
+#include <command.h>
+#include <getopt.h>
+#include <console.h>
+
+static int do_uart_console(int argc, char *argv[])
+{
+	struct device_node *uart_node;
+	int uart_num = -1, opt;
+	char *alias_name;
+
+	while ((opt = getopt(argc, argv, "e:")) > 0) {
+		switch (opt) {
+		case 'e':
+			uart_num = simple_strtoul(optarg, NULL, 0);
+			break;
+		}
+	}
+
+	alias_name = basprintf("serial%d", uart_num);
+
+	uart_node = of_find_node_by_alias(of_get_root_node(), alias_name);
+	if (!uart_node)
+		return -ENODEV;
+
+	if (!of_device_enable_and_register(uart_node))
+		return -ENODEV;
+
+	return 0;
+}
+
+BAREBOX_CMD_HELP_START(uart_console)
+BAREBOX_CMD_HELP_TEXT("Options:")
+BAREBOX_CMD_HELP_OPT("-e <NUM>", "enable uart<NUM> as console\n")
+BAREBOX_CMD_HELP_END
+
+BAREBOX_CMD_START(uart_console)
+	.cmd		= do_uart_console,
+	BAREBOX_CMD_DESC("activate uart as console")
+	BAREBOX_CMD_OPTS("[-e]")
+	BAREBOX_CMD_GROUP(CMD_GRP_MISC)
+	BAREBOX_CMD_HELP(cmd_uart_console_help)
+BAREBOX_CMD_END
diff --git a/common/blspec.c b/common/blspec.c
index ad80d7a8cde..ddaffa657d9 100644
--- a/common/blspec.c
+++ b/common/blspec.c
@@ -21,6 +21,7 @@
 #include <linux/stat.h>
 #include <linux/err.h>
 #include <mtd/ubi-user.h>
+#include <libgen.h>
 
 /*
  * blspec_entry_var_set - set a variable to a value
@@ -540,16 +541,98 @@ static bool entry_is_match_machine_id(struct blspec_entry *entry)
 	return ret;
 }
 
+/*
+ * blspec_check_conf_file - check if config file is valid
+ *
+ * return 0 if config file not valid != 0 otherwise
+ */
+static int blspec_check_conf_file(struct bootentries *bootentries,
+				   char *configname)
+{
+	int ret = 0;
+	char *dot;
+	struct stat s;
+
+	pr_debug("%s: %s\n", __func__, configname);
+
+	dot = strrchr(configname, '.');
+	if (!dot)
+		goto out;
+
+	if (strcmp(dot, ".conf"))
+		goto out;
+
+	if (stat(configname, &s))
+		goto out;
+
+	if (!S_ISREG(s.st_mode))
+		goto out;
+
+	return !blspec_have_entry(bootentries, configname);
+out:
+	return ret;
+}
+
+/*
+ * blspec_get_entry - create and set content of blspec entry
+ *
+ * return NULL if error occur else valid blspech entry
+ */
+static struct blspec_entry *blspec_get_entry(struct bootentries *bootentries,
+					     char *configname, const char* root)
+{
+	struct blspec_entry *entry = NULL;
+	char *devname = NULL, *hwdevname = NULL;
+
+	entry = blspec_entry_open(bootentries, configname);
+	if (IS_ERR(entry))
+		goto out;
+
+	entry->rootpath = xstrdup(root);
+	entry->configpath = xstrdup(configname);
+	entry->cdev = get_cdev_by_mountpath(root);
+
+	if (!entry_is_of_compatible(entry))
+		goto err_out;
+
+	if (!entry_is_match_machine_id(entry))
+		goto err_out;
+
+	if (entry->cdev && entry->cdev->dev) {
+		devname = xstrdup(dev_name(entry->cdev->dev));
+		if (entry->cdev->dev->parent)
+			hwdevname = xstrdup(dev_name(entry->cdev->dev->parent));
+	}
+
+	entry->entry.title = xasprintf("%s (%s)", blspec_entry_var_get(entry, "title"),
+				       configname);
+	entry->entry.description = basprintf("blspec entry, device: %s hwdevice: %s",
+					    devname ? devname : "none",
+					    hwdevname ? hwdevname : "none");
+	free(devname);
+	free(hwdevname);
+
+	entry->entry.me.type = MENU_ENTRY_NORMAL;
+	entry->entry.release = blspec_entry_free;
+
+	return entry;
+
+err_out:
+	blspec_entry_free(&entry->entry);
+out:
+	return NULL;
+}
+
 /*
  * blspec_scan_directory - scan over a directory
  *
- * Given a root path collects all bootentries entries found under /bootentries/entries/.
+ * Given a root path collects all bootentries entries found under
+ * /loader/entries/.
  *
  * returns the number of entries found or a negative error value otherwise.
  */
 int blspec_scan_directory(struct bootentries *bootentries, const char *root)
 {
-	struct blspec_entry *entry;
 	DIR *dir;
 	struct dirent *d;
 	char *abspath;
@@ -573,93 +656,93 @@ int blspec_scan_directory(struct bootentries *bootentries, const char *root)
 	}
 
 	while ((d = readdir(dir))) {
+		struct blspec_entry *entry;
 		char *configname;
-		struct stat s;
-		char *dot;
-		char *devname = NULL, *hwdevname = NULL;
 
 		if (*d->d_name == '.')
 			continue;
 
 		configname = basprintf("%s/%s", abspath, d->d_name);
 
-		dot = strrchr(configname, '.');
-		if (!dot) {
+		ret = blspec_check_conf_file(bootentries, configname);
+		if (!ret) {
 			free(configname);
 			continue;
 		}
 
-		if (strcmp(dot, ".conf")) {
-			free(configname);
-			continue;
+		entry = blspec_get_entry(bootentries, configname, root);
+		if (entry) {
+			++found;
+			bootentries_add_entry(bootentries, &entry->entry);
 		}
+	}
 
-		ret = stat(configname, &s);
-		if (ret) {
-			free(configname);
-			continue;
-		}
+	ret = found;
 
-		if (!S_ISREG(s.st_mode)) {
-			free(configname);
-			continue;
-		}
+	closedir(dir);
+err_out:
+	if (!IS_ERR(nfspath))
+		free(nfspath);
+	free(abspath);
 
-		if (blspec_have_entry(bootentries, configname)) {
-			free(configname);
-			continue;
-		}
+	return ret;
+}
 
-		entry = blspec_entry_open(bootentries, configname);
-		if (IS_ERR(entry)) {
-			free(configname);
-			continue;
-		}
+/*
+ * blspec_scan_file - scan a certainly blspec config file
+ *
+ * returns the 1 if valid entrie found, 0 or a negative error value otherwise.
+ */
+int blspec_scan_file(struct bootentries *bootentries, const char *file)
+{
+	int ret = 0;
+	struct blspec_entry *entry;
+	char *abspath, *root = NULL;
+	char *sep, *confdir;
+	const char *dirname = "loader/entries";
 
-		entry->rootpath = xstrdup(root);
-		entry->configpath = configname;
-		entry->cdev = get_cdev_by_mountpath(root);
+	if (strncmp(file, "file://", 7)) {
+		ret = -EINVAL;
+		goto out;
+	}
 
-		if (!entry_is_of_compatible(entry)) {
-			blspec_entry_free(&entry->entry);
-			continue;
-		}
+	file += 7;
 
-		if (!entry_is_match_machine_id(entry)) {
-			blspec_entry_free(&entry->entry);
-			continue;
-		}
+	abspath = xstrdup(file);
 
-		found++;
+	ret = blspec_check_conf_file(bootentries, abspath);
+	if (!ret) {
+		ret = -EINVAL;
+		goto out_free;
+	}
 
-		if (entry->cdev && entry->cdev->dev) {
-			devname = xstrdup(dev_name(entry->cdev->dev));
-			if (entry->cdev->dev->parent)
-				hwdevname = xstrdup(dev_name(entry->cdev->dev->parent));
-		}
+	root = xstrdup(abspath);
 
-		entry->entry.title = xasprintf("%s (%s)", blspec_entry_var_get(entry, "title"),
-					       configname);
-		entry->entry.description = basprintf("blspec entry, device: %s hwdevice: %s",
-						    devname ? devname : "none",
-						    hwdevname ? hwdevname : "none");
-		free(devname);
-		free(hwdevname);
+	sep = strrchr(root, '/');
+	if (!sep) {
+		ret = -EINVAL;
+		goto out_free;
+	}
 
-		entry->entry.me.type = MENU_ENTRY_NORMAL;
-		entry->entry.release = blspec_entry_free;
+	*sep = 0;
+	confdir = sep - strlen(dirname);
 
-		bootentries_add_entry(bootentries, &entry->entry);
+	if (strncmp(confdir, dirname, strlen(dirname))) {
+		ret = -EINVAL;
+		goto out_free;
 	}
 
-	ret = found;
+	entry = blspec_get_entry(bootentries, abspath, root);
+	if (!entry)
+		goto out_free;
 
-	closedir(dir);
-err_out:
-	if (!IS_ERR(nfspath))
-		free(nfspath);
-	free(abspath);
+	bootentries_add_entry(bootentries, &entry->entry);
+	ret = 1;
 
+out_free:
+	free(root);
+	free(abspath);
+out:
 	return ret;
 }
 
@@ -878,6 +961,12 @@ static int blspec_bootentry_provider(struct bootentries *bootentries,
 			found += ret;
 	}
 
+	if (!strncmp(name, "file://", 7)) {
+		ret = blspec_scan_file(bootentries, name);
+		if (ret > 0)
+			found += ret;
+	}
+
 	return found;
 }
 
diff --git a/defaultenv/defaultenv-pfc-base/bin/init b/defaultenv/defaultenv-pfc-base/bin/init
new file mode 100644
index 00000000000..150f5f6f6f2
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/init
@@ -0,0 +1,86 @@
+#!/bin/sh
+
+export PATH=/env/bin
+
+global hostname
+global user
+global autoboot_timeout
+global autoboot_abort_key
+global boot.default
+global linux.bootargs.base
+global linux.bootargs.console
+#linux.bootargs.dyn.* will be cleared at the beginning of boot
+global linux.bootargs.dyn.ip
+global linux.bootargs.dyn.root
+global editcmd
+
+[ -z "${global.hostname}" ] && global.hostname=generic
+[ -z "${global.user}" ] && global.user=none
+magicvar -a global.user "username (used in network filenames)"
+[ -z "${global.autoboot_timeout}" ] && global.autoboot_timeout=3
+magicvar -a global.autoboot_timeout "timeout in seconds before automatic booting"
+[ -z "${global.autoboot_abort_key}" ] && global.autoboot_abort_key=any
+magicvar -a global.autoboot_abort_key "key to abort automatic booting (valid options: any, ctrl-c)"
+[ -z "${global.boot.default}" ] && global.boot.default=net
+[ -z "${global.editcmd}" ] && global.editcmd=sedit
+
+[ -e /env/config-board ] && /env/config-board
+/env/config
+
+# allow to stop the boot before execute the /env/init/*
+# but without waiting
+timeout -s -a -v key 0
+[ "$?" = 1 ] && global.autoboot="abort"
+
+echo -e -n "\e[?25h"
+if [ "${key}" = "q" ]; then
+	exit
+fi
+
+for i in /env/init/*; do
+	. $i
+done
+
+if [ "${global.autoboot_abort_key}" = "ctrl-c" ]; then
+	abort_string="ctrl-c"
+	abort_args="-c"
+else
+	abort_string="any key"
+	abort_args="-a -e"
+fi
+
+if [ -e /env/menu ]; then
+	echo -e -n "\nHit m for menu or $abort_string to stop autoboot: "
+else
+	echo -e -n "\nHit $abort_string to stop autoboot: "
+fi
+
+if [ ! "$global.autoboot" = "abort" ]; then
+	timeout $abort_args $global.autoboot_timeout -v key
+	[ "$?" = 1 ] && global.autoboot="abort"
+fi
+
+for i in /env/init_post_autoboot/*; do
+	. $i
+done
+
+if [ "${key}" = "q" ]; then
+	exit
+fi
+
+if [ ! "$global.autoboot" = "abort" ]; then
+	boot
+	if [ ! "$?" = "0" ]; then
+		echo -e ${error} "$0: could not boot at least one of this bootsources: ${global.boot.default}"
+		pfc-config-broken-boot
+		exit 1
+	fi
+fi
+
+if [ -e /env/menu ]; then
+	if [ "${key}" != "m" ]; then
+		echo -e "\ntype exit to get to the menu"
+		sh
+	fi
+	/env/menu/mainmenu
+fi
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-check-for-debug-uart b/defaultenv/defaultenv-pfc-base/bin/pfc-check-for-debug-uart
new file mode 100644
index 00000000000..0a8d509e88c
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-check-for-debug-uart
@@ -0,0 +1,20 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+let debug_mode_mask="(1<<0)"
+let debug_mode_enable="0x${global.pfc.boot_mode_id} & 0x${debug_mode_mask}"
+
+if [ "${debug_mode_enable}" = "${debug_mode_mask}" ]; then
+	echo -e ${warning} "uart debug mode active"
+	global.autoboot_timeout=3
+	global.pfc.debug_mode_active=true
+
+	# one some devices the debug uart interface is only
+	# available through the jtag interface. This is not
+	# always wired to the mainboard (e.g. PAC-Devices).
+	uart_console -e ${global.pfc.barebox_uart}
+
+	# on devices with usb interface enable the usb gadget, too.
+	usbgadget ${global.pfc.usbgadget_options}
+fi
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-config-broken-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-config-broken-boot
new file mode 100644
index 00000000000..1e3b3594891
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-config-broken-boot
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+# first switch of any previously activated leds
+led_mode -s -c yellow -v off
+led_mode -s -c red -v on
+
+global.pfc.boot_mode="broken"
+
+# set autoboot variable to 1, to stop auto booting in
+# /env/bin/init and stay in shell.
+global.autoboot=1
+uart_console -e ${global.pfc.barebox_uart}
+
+echo -e ${error} "$0: setting boot_mode to: ${global.pfc.boot_mode}"
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-config-default-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-config-default-boot
new file mode 100644
index 00000000000..ee142a32fc9
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-config-default-boot
@@ -0,0 +1,60 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+led_mode -s -c yellow -v on
+
+global.autoboot_timeout=0
+global.boot.watchdog_timeout=${global.pfc.watchdog_timeout_linux_load}
+global.linux.bootargs.base="bootversion=${global.version} reset_state=${global.system.reset}"
+global.boot.default="bootchooser"
+
+sd_blspec="${global.pfc.sd_rootfs}/boot/sd/loader/entries/${global.model}-${global.pfc.devconf}.conf"
+sd_legacy_uImage="${global.pfc.sd_boot}/uImage"
+
+emmc_blspec_rootfs0="${global.pfc.emmc_rootfs0}/boot/emmc0/loader/entries/${global.model}-${global.pfc.devconf}.conf"
+emmc_blspec_rootfs1="${global.pfc.emmc_rootfs1}/boot/emmc1/loader/entries/${global.model}-${global.pfc.devconf}.conf"
+
+nand_blspec_rootfs0="${global.pfc.nand_rootfs0}/boot/nand0/loader/entries/${global.model}-${global.pfc.devconf}.conf"
+nand_blspec_rootfs1="${global.pfc.nand_rootfs1}/boot/nand1/loader/entries/${global.model}-${global.pfc.devconf}.conf"
+
+if [ -e "${global.pfc.emmc}" ]; then
+	global.bootchooser.rootfs.1.boot="file://${emmc_blspec_rootfs0}"
+	global.bootchooser.rootfs.2.boot="file://${emmc_blspec_rootfs1}"
+
+elif [ -e "${global.pfc.nand}" ]; then
+	global.bootchooser.rootfs.1.boot="file://${nand_blspec_rootfs0}"
+	global.bootchooser.rootfs.2.boot="file://${nand_blspec_rootfs1}"
+else
+	# remove bootchooser from default boot source
+	global.boot.default=""
+	echo -e ${warning} "$0: no valid boot device found for bootchooser"
+fi
+
+if [ "${global.pfc.disable_sd_boot}" = 0 ]; then
+	if [ -e "${global.pfc.sd}" ] && [ -e "${sd_blspec}" ]; then
+		global.boot.default="file://${sd_blspec} bootchooser"
+
+	elif [ -e "${global.pfc.sd}" ] && [ -e "${sd_legacy_uImage}" ]; then
+		# disable watchdog in case of an legacy boot, because we dont know if the
+		# watchdog is disabled per default in legacy kernel.
+		global.boot.watchdog_timeout=0
+
+		global.bootm.boot_atag=true
+		global.boot.default="sd-legacy bootchooser"
+	fi
+fi
+
+if [ "${global.pfc.dhcpboot}" = 1 ]; then
+	global.boot.default="dhcp-boot $global.boot.default"
+fi
+
+if [ -z "${global.boot.default}" ]; then
+	echo -e ${error} "$0: no valid boot device available"
+	exit 1
+fi
+
+pfc-check-for-debug-uart
+pfc-set-linux-console
+
+echo -e ${info} "default boot order is: $global.boot.default"
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-config-production-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-config-production-boot
new file mode 100644
index 00000000000..3ebde65812f
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-config-production-boot
@@ -0,0 +1,9 @@
+#!/bin/sh
+
+global.linux.bootargs.productionmode="production_mode=1"
+global.linux.bootargs.console="console=${global.pfc.linux_uart_device}${global.pfc.barebox_linux_uart},115200n8"
+global.linux.bootargs.watchdog=""
+global.boot.watchdog_timeout=0
+
+led_mode -m -c green
+pfc-config-setupfw-generic-boot
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-boot
new file mode 100644
index 00000000000..09d872be4ea
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-boot
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+global.linux.bootargs.productionmode="production_mode=2"
+global.linux.bootargs.console="console="
+
+led_mode -m -c red
+pfc-config-setupfw-generic-boot
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-generic-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-generic-boot
new file mode 100644
index 00000000000..2be71c643ca
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-generic-boot
@@ -0,0 +1,18 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+uart_console -e ${global.pfc.barebox_uart}
+global.autoboot_timeout=3
+global.linux.bootargs.base="root=/dev/ram0 rdinit=/init.sh quiet macaddr=${eth0.ethaddr}"
+
+if [ -e "${global.pfc.sd}" ] &&
+   [ -e "${global.pfc.sd_boot}/setupfw" ] &&
+   [ -e "${global.pfc.sd_boot}/oftree-${global.board.variant}-setupfw.dtb" ] ; then
+	global.boot.default="sd-setupfw net-setupfw"
+
+else
+	global.boot.default="net-setupfw"
+fi
+
+echo -e ${info} "default boot order is: $global.boot.default"
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-debug-uart-mode b/defaultenv/defaultenv-pfc-base/bin/pfc-debug-uart-mode
new file mode 100644
index 00000000000..bb26941c53e
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-debug-uart-mode
@@ -0,0 +1,37 @@
+#!/bin/sh
+
+mode="unknown"
+let debug_mask="(1<<0)"
+
+while getopt "edh" opt; do
+	if [ ${opt} = e ]; then
+                mode="enable"
+	elif [ ${opt} = d ]; then
+                mode="disable"
+	elif [ ${opt} = h ]; then
+		mode="unknown"
+	fi
+done
+
+if [ "${mode}" = "unknown" ]; then
+	echo "usage: $0 [-ed]"
+	echo ""
+	echo "control debug uart mode. Mode is set persistent through eeprom bit "develop-mode-enable" in eeprom"
+	echo ""
+	echo "-e enable debug uart mode\n"
+	echo "-d disable debug uart mode\n"
+	echo ""
+	exit 1
+fi
+
+if [ "${mode}" = "enable" ]; then
+	let debug_enable="0x${global.pfc.boot_mode_id} | 0x${debug_mask}"
+else
+	let debug_enable="0x${global.pfc.boot_mode_id} & ~0x${debug_mask}"
+fi
+
+# write persistent to eeprom
+xsection.boot_mode_id=${debug_enable}
+
+# also update global variable
+global.pfc.boot_mode_id=${xsection.boot_mode_id}
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-detect-boot-mode b/defaultenv/defaultenv-pfc-base/bin/pfc-detect-boot-mode
new file mode 100644
index 00000000000..ec2a4f5c8cd
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-detect-boot-mode
@@ -0,0 +1,50 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+let setup_fw_mask="(1 << 5)"
+let setup_fw_enable="0x${global.pfc.boot_mode_id} & ${setup_fw_mask}"
+let setup_fw_disable="0x${global.pfc.boot_mode_id} & ~${setup_fw_mask}"
+
+let disable_sd_boot_mask="(1 << 0)"
+let disable_sd_boot="0x${global.pfc.boot_mode_id_ext} & ${disable_sd_boot_mask}"
+
+let dhcpboot_mask="(1 << 1)"
+let dhcpboot="0x${global.pfc.boot_mode_id_ext} & ${dhcpboot_mask}"
+
+pfc-validate-ethaddr
+
+if [ "${dhcpboot}" = "${dhcpboot_mask}" ]; then
+	global.pfc.dhcpboot=1
+	echo -e ${warning} "dhcpboot enabled."
+fi
+
+if [ "${disable_sd_boot}" = "${disable_sd_boot_mask}" ]; then
+	global.pfc.disable_sd_boot=1
+	echo -e ${warning} "booting from sd disabled"
+fi
+
+if [ "${global.pfc.ethaddr_is_valid}" = false ]; then
+        global.pfc.boot_mode="production"
+
+elif [ -e "${global.pfc.sd}" ] && [ "${global.pfc.disable_sd_boot}" = 0 ]; then
+
+	# if a downgrade.bin.<platform-suffix> file is found on the first
+	# sd/mmc boot partition, we execute it.
+	# if downgrading will be executed successfully,
+	# we never come back here.
+	if [ -e "${global.pfc.downgrade_img}" ]; then
+        	global.pfc.boot_mode="downgrade"
+
+	# if a custom setup script is in located in the
+	# first sd/mmc card partition (fat), execute it.
+	elif [ -e "${global.pfc.custom_sh}" ]; then
+        	global.pfc.boot_mode="custom"
+	fi
+
+elif [ "${setup_fw_enable}" = "${setup_fw_mask}" ]; then
+        global.pfc.boot_mode="setupfw"
+	xsection.boot_mode_id="${setup_fw_disable}"
+fi
+
+echo -e ${info} "detected boot_mode: ${global.pfc.boot_mode}"
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-erase-flash-ubidata b/defaultenv/defaultenv-pfc-base/bin/pfc-erase-flash-ubidata
new file mode 100644
index 00000000000..fcb2c80bc7b
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-erase-flash-ubidata
@@ -0,0 +1,32 @@
+#!/bin/sh
+
+source /env/data/print-msg-formats
+
+# on am35xx based targets we need to set the ecc-mode
+nand_bch8="/env/data/nand-ecc-bch8"
+
+ubi_image="$1"
+
+if [ -z ${ubi_image} ] || [ ! -e "${ubi_image}" ]; then
+	echo -e ${error} "$0: no ubi-image to flash given"
+	exit 1
+fi
+
+# detach ubi device if attached
+[ -e "${global.pfc.nand_ubidata}.ubi" ] && ubidetach ${global.pfc.nand_ubidata}
+
+erase ${global.pfc.nand_ubidata}
+
+# here we also need to set the ecc-mode on
+# am335x based targets.
+if [ -e "${nand_bch8}" ]; then
+	${nand_bch8}
+fi
+
+ubiformat -q ${global.pfc.nand_ubidata} -y -e 0 -f ${ubi_image}
+if [ $? -ne 0 ]; then
+        echo -e ${error} "$0: error due flashing ${ubi_image} on ${global.pfc.nand_ubidata}"
+        exit 1
+fi
+
+exit 0
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-exec-custom-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-exec-custom-boot
new file mode 100644
index 00000000000..4421f285b89
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-exec-custom-boot
@@ -0,0 +1,15 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+led_mode -m -c green
+
+# set autoboot variable to 1, to stop auto booting in
+# /env/bin/init and stay in shell.
+global.autoboot=1
+uart_console -e ${global.pfc.barebox_uart}
+
+echo -e ${info} "execute custom script: ${global.pfc.custom_sh}"
+
+${global.pfc.custom_sh}
+exit $?
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-exec-downgrade-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-exec-downgrade-boot
new file mode 100644
index 00000000000..0b1bb617506
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-exec-downgrade-boot
@@ -0,0 +1,193 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+uart_console -e ${global.pfc.barebox_uart}
+
+# set autoboot variable to 1, to stop auto booting in
+# /env/bin/init and stay in shell.
+global.autoboot=1
+
+downgrade_lzo="downgrade.bin.${global.board.variant}"
+downgrade_script="downgrade"
+
+###############################
+##### legacy parts ############
+###############################
+
+mtd_linux1="mtd0_raw_linux1"
+mtd_linux2="mtd0_raw_linux2"
+mtd_data="mtd2_fs_data"
+mtd_xload="mtd3_raw_xload"
+mtd_barebox="mtd4_raw_barebox"
+mtd_barebox_env="mtd5_raw_barebox-env"
+mtd_product="mtd6_raw_product"
+mtd_recovery="mtd7_raw_recovery"
+mtd_parts="${mtd_linux1} ${mtd_linux2} ${mtd_data} ${mtd_xload} ${mtd_barebox} ${mtd_barebox_env} ${mtd_product} ${mtd_recovery}"
+
+recovery_parts="512k@0k(${mtd_xload}),1024k@512k(${mtd_barebox}),256k@1536k(${mtd_barebox_env}),256k@1792k(${mtd_product}),40192k@2048k(${mtd_recovery}),4096k@42240k(${mtd_linux1}),4096k@46336k(${mtd_linux2}),-@50432k(${mtd_data})"
+
+mlo="downgrade.mlo--nand"
+barebox="downgrade.barebox.img"
+recovery="recovery"
+
+###############################
+
+nand_hamming="/env/data/nand-ecc-hamming"
+nand_bch8_legacy="/env/data/nand-ecc-bch8-legacy"
+
+led_mode -m -c red -t
+
+echo -e ${info} "starting firmware downgrade..."
+echo -e ${info} "checking the environment..."
+
+# check if mount point is at correct location
+if [ ! -e "${global.pfc.sd_boot}" ]; then
+
+	echo -e ${error} "mount point ${global.pfc.sd_boot} not available"
+	exit 1
+
+fi
+
+# check if all recovery files are available
+if [ ! -e "${global.pfc.sd_boot}/${mlo}" ]; then
+
+	echo -e ${error} "recovery file: ${global.pfc.sd_boot}/${mlo} not available"
+	exit 1
+
+fi
+
+if [ ! -e "${global.pfc.sd_boot}/${barebox}" ]; then
+
+	echo -e ${error} "recovery file: ${global.pfc.sd_boot}/${barebox} not available"
+	exit 1
+
+fi
+
+if [ ! -e "${global.pfc.sd_boot}/${recovery}" ]; then
+
+	echo -e ${error} "recovery file: ${global.pfc.sd_boot}/${recovery} not available"
+	exit 1
+
+fi
+
+# reset bootloader index in eeprom
+echo -e ${info} "restore bootloader index..."
+xsection.blidx=0
+
+echo -e ${info} "restore recovery partitions..."
+
+# delete current mlo partitions
+for partition in ${global.pfc.nand_mlo_parts}; do
+	nand -d ${partition}.bb
+	delpart ${partition}
+done
+
+# delete current boot partitions
+for partition in ${global.pfc.nand_boot_parts}; do
+	nand -d ${partition}.bb
+	delpart ${partition}
+done
+
+# delete current data partition
+nand -d ${global.pfc.nand_ubidata}.bb
+delpart ${global.pfc.nand_ubidata}
+
+# restore recovery partitions
+mtdparts-add -b -d nand0 -p ${recovery_parts}
+
+# do additional check for created recovery partitions
+for partition in ${mtd_parts}; do
+	if [ ! -e "${global.pfc.nand}.${partition}" ]; then
+		echo -e ${error} "recovery-partition ${global.pfc.nand}.${partition} not available"
+		exit 1
+	fi
+
+	if [ ! -e "${global.pfc.nand}.${partition}.bb" ]; then
+		echo -e ${error} "recovery-partition ${global.pfc.nand}.${partition}.bb not available"
+		exit 1
+	fi
+done
+
+# check if all nand ecc-modes are available
+[ ! -e "${nand_hamming}" ] && echo -e ${error} "ecc-mode ${nand_hamming} not available" && exit 1
+[ ! -e "${nand_bch8_legacy}" ] && echo -e ${error} "ecc-mode ${nand_bch8_legacy} not available" && exit 1
+
+echo ""
+echo -e ${warning} "####################################################################"
+echo -e ${warning} "ATTENTION: DO NOT SWITCH OFF THE DEVICE DURING ERASE AND FLASH STEPS"
+echo -e ${warning} "####################################################################"
+echo ""
+echo -e -n ${warning} "PRESS ANY KEY TO ABORT ERASE AND FLASH STEPS: "
+
+timeout -a 3
+res=$?
+if [ ${res} -eq 1 ]; then
+
+	echo -e ${warning} "ABORTED BY USER...BOOT TO SHELL"
+	exit 1
+
+fi
+
+echo -e ${warning} "erase bootloader partitions..."
+
+# erase all bootloader partitions
+erase ${global.pfc.nand}.${mtd_xload}
+erase ${global.pfc.nand}.${mtd_barebox}.bb
+
+echo -e ${warning} "flash mlo and barebox..."
+
+# flash mlo
+${nand_hamming}
+#    -- first  128k
+memcpy -s ${global.pfc.sd_boot}/${mlo} -d ${global.pfc.nand}.${mtd_xload} 0x0 0x0
+#    -- second 128k
+memcpy -s ${global.pfc.sd_boot}/${mlo} -d ${global.pfc.nand}.${mtd_xload} 0x0 0x20000
+#    -- third  128k
+memcpy -s ${global.pfc.sd_boot}/${mlo} -d ${global.pfc.nand}.${mtd_xload} 0x0 0x40000
+#    -- fourth 128k
+memcpy -s ${global.pfc.sd_boot}/${mlo} -d ${global.pfc.nand}.${mtd_xload} 0x0 0x60000
+
+
+# flash barebox
+${nand_bch8_legacy}
+memcpy -s ${global.pfc.sd_boot}/${barebox} -d ${global.pfc.nand}.${mtd_barebox}.bb 0x0 0x0
+
+echo -e ${warning} "flash recovery image..."
+erase ${global.pfc.nand}.${mtd_recovery}.bb 0x0
+memcpy -s ${global.pfc.sd_boot}/${recovery} -d ${global.pfc.nand}.${mtd_recovery}.bb 0x0 0x0
+
+echo -e ${warning} "done..."
+echo ""
+echo -e ${warning} "############################################################"
+echo -e ${warning} "ATTENTION: DO NOT SWITCH OFF THE DEVICE DURING FACTORY RESET"
+echo -e ${warning} "############################################################"
+echo ""
+
+
+# setup bootargs
+echo -e ${info} "setup bootargs"
+
+global linux.bootargs.dyn.root="root=/dev/ram0 rdinit=/init.sh"
+global linux.bootargs.dyn.ip=""
+global linux.bootargs.dyn.macaddr=""
+global linux.bootargs.bootmode="pac_boot_id=0x1"
+global linux.bootargs.productionmode="production_mode=2"
+global linux.bootargs.devconf="devconf=0x0"
+
+# we need to clear the console kernel parameter. Otherwise the recovery step will
+# fail and damage the internal nand partiton layout.
+global.linux.bootargs.console=""
+
+# load production-firmware from nand partition and start it
+echo -e ${info} "now boot recovery image in factory-reset-mode"
+echo ""
+
+global.bootm.boot_atag=true
+bootm -v -f ${global.pfc.nand}.${mtd_recovery}.bb
+if [ ! $? = "0" ]; then
+	echo -e ${error} "could not start recovery image...booting to shell..."
+	exit 1
+fi
+
+exit $?
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-set-linux-console b/defaultenv/defaultenv-pfc-base/bin/pfc-set-linux-console
new file mode 100644
index 00000000000..e644823bd59
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-set-linux-console
@@ -0,0 +1,23 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+let uart_mask="(1<<1)"
+let uart_enable="0x${global.pfc.boot_mode_id} & 0x${uart_mask}"
+
+if [ "${uart_enable}" = "${uart_mask}" ]; then
+	global.linux.bootargs.console="console=${global.pfc.linux_uart_device}${global.pfc.linux_uart},115200n8"
+
+elif [ "${global.bootm.boot_atag}" = true ]; then
+	# in case of an legacy boot (e.g. kernel 3.6.11, FW < 5) we are not
+	# allowed to set console=null because this will break the init-process
+	# and the boot hangs.
+	global.linux.bootargs.console=""
+
+elif [ "${global.pfc.debug_mode_active}" = true ]; then
+	global.linux.bootargs.console="console=${global.pfc.linux_uart_device}${global.pfc.barebox_linux_uart},115200n8"
+else
+	global.linux.bootargs.console="console=null"
+fi
+
+echo -e ${info} "setting linux console to: $global.linux.bootargs.console"
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-switch-linux-console b/defaultenv/defaultenv-pfc-base/bin/pfc-switch-linux-console
new file mode 100644
index 00000000000..7a0d30d5603
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-switch-linux-console
@@ -0,0 +1,37 @@
+#!/bin/sh
+
+mode="unknown"
+let uart_mask="(1<<1)"
+
+while getopt "edh" opt; do
+	if [ ${opt} = e ]; then
+                mode="enable"
+	elif [ ${opt} = d ]; then
+                mode="disable"
+	elif [ ${opt} = h ]; then
+		mode="unknown"
+	fi
+done
+
+if [ "${mode}" = "unknown" ]; then
+	echo "usage: $0 [-ed]"
+	echo ""
+	echo "control serial console bit. Mode is set persistent through eeprom bit "uart-enable" in eeprom"
+	echo ""
+	echo "-e enable linux uart mode\n"
+	echo "-d disable linux uart mode\n"
+	echo ""
+	exit 1
+fi
+
+if [ "${mode}" = "enable" ]; then
+	let uart_enable="0x${global.pfc.boot_mode_id} | 0x${uart_mask}"
+else
+	let uart_enable="0x${global.pfc.boot_mode_id} & ~0x${uart_mask}"
+fi
+
+# write persistent to eeprom
+xsection.boot_mode_id=${uart_enable}
+
+# also update global variable
+global.pfc.boot_mode_id=${xsection.boot_mode_id}
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-validate-ethaddr b/defaultenv/defaultenv-pfc-base/bin/pfc-validate-ethaddr
new file mode 100644
index 00000000000..8ac486514a1
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-validate-ethaddr
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+ethaddr_match -i eth0 -p "00:30:de"
+if [ "$?" = 0 ]; then
+        global.pfc.ethaddr_is_valid="true"
+else
+        global.pfc.ethaddr_is_valid="false"
+fi
+
+echo -e ${info} "ethaddr is valid: $global.pfc.ethaddr_is_valid"
diff --git a/defaultenv/defaultenv-pfc-base/boot/dhcp-boot b/defaultenv/defaultenv-pfc-base/boot/dhcp-boot
new file mode 100644
index 00000000000..a341a2600da
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/boot/dhcp-boot
@@ -0,0 +1,22 @@
+#!/bin/sh
+
+# disable watchdog, otherwise the device will be resettet when the dhcp-request
+# takes to long.
+wd 0
+
+# send magic string with the dhcp-request to signal the dhcp-boot state
+global.dhcp.option224="cit-recover"
+
+ifup eth0
+
+if [ ! -z "${global.dhcp.bootfile}" ]; then
+	echo -e ${info} "enter DHCPBOOT now"
+
+	tftp ${global.dhcp.bootfile}
+
+	echo -e ${info} "DHCPBOOT: exec <${global.dhcp.bootfile}>"
+	./${global.dhcp.bootfile}
+fi
+
+# enable watchdog again, if the dhcp-server does not provide any bootfile.
+wd $global.pfc.watchdog_timeout_linux_load
diff --git a/defaultenv/defaultenv-pfc-base/boot/net-setupfw b/defaultenv/defaultenv-pfc-base/boot/net-setupfw
new file mode 100644
index 00000000000..a28eca3b738
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/boot/net-setupfw
@@ -0,0 +1,94 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+global.dhcp.retries=1000
+global.dhcp.vendor_id="750-8206"
+global.dhcp.option224="barebox running"
+
+ifup ${global.pfc.eth}
+
+if [ ${eth0.ipaddr} != "0.0.0.0" ] && [ ${eth0.serverip} != "0.0.0.0" ] &&
+  				      [ ! -z "${global.dhcp.bootfile}"  ]; then
+
+	echo -e ${info} "get ${global.dhcp.bootfile} from tftp server ${eth0.serverip}."
+
+	tftp ${global.dhcp.bootfile}
+	if [ "$?" = 0 ]; then
+
+		# Flash PFC200v3 G2 EMMC
+		if [ -e "${global.pfc.emmc}" ]; then
+			echo -e ${info} "flash ${global.pfc.bootfile} to ${global.pfc.emmc}"
+			umount /boot
+			umount ${global.pfc.emmc}.0
+			delpart ${global.pfc.emmc}.0
+
+			cp ${global.dhcp.bootfile} ${global.pfc.emmc}
+			if [ $? -ne 0 ]; then
+				echo -e ${error} "$0: error while flashing ${global.dhcp.bootfile} on ${global.pfc.emmc}"
+				#all_lights -s 1 -c red
+				exit 1
+			fi
+
+			# normally there are no available partitions on emmc devices at the commissioner.
+			# With the result that we dont see any partitions under /dev. After we flashed the
+			# emmc image to the device we need to rescan the partiton tables and add the new
+			# flashed partitions under /dev.
+			${global.pfc.emmc_name}.scan=1
+			if [ $? -ne 0 ]; then
+				echo -e ${PRINT_ERROR} "error scanning partitions"
+				all_lights -s 1 -c red
+				exit 1
+			fi
+
+			# set setupfw image and dtb file to newly flashed emmc image files
+			if [ ! -e "${global.pfc.emmc_boot}/setupfw" ] ||
+			   [ ! -e "${global.pfc.emmc_boot}/oftree-${global.board.variant}-setupfw.dtb" ]; then
+				echo -e ${error} "$0: no setupfw on newly flashed emmc found"
+				#all_lights -s 1 -c red
+				exit 1
+			fi
+
+			global.bootm.image="${global.pfc.emmc_boot}/setupfw"
+			global.bootm.oftree="${global.pfc.emmc_boot}/oftree-${global.board.variant}-setupfw.dtb"
+
+		# Flash NAND flash devices, like SRC
+		elif [ -e "${global.pfc.nand}" ]; then
+
+			echo -e ${info} "flash ${global.dhcp.bootfile} to ${global.pfc.nand_ubidata}"
+
+			pfc-erase-flash-ubidata ${global.dhcp.bootfile}
+			if [ $? -ne 0 ]; then
+				echo -e ${error} "$0: error while flashing ${global.dhcp.bootfile} on ${global.pfc.nand_ubidata}"
+				#all_lights -s 1 -c red
+				exit 1
+			fi
+
+			automount -d ${global.pfc.nand_boot} "ubiattach ${global.pfc.nand_ubidata}; mount -t ubifs ${global.pfc.nand_ubidata_boot} ${global.pfc.nand_boot}"
+
+			# set setupfw image and dtb file to newly flashed nand image files
+			if [ ! -e "${global.pfc.nand_boot}/setupfw" ] ||
+			   [ ! -e "${global.pfc.nand_boot}/oftree-${global.board.variant}-setupfw.dtb" ]; then
+				echo -e ${error} "$0: no setupfw on newly flashed nand found"
+				#all_lights -s 1 -c red
+				exit 1
+			fi
+
+			global.bootm.image="${global.pfc.nand_boot}/setupfw"
+			global.bootm.oftree="${global.pfc.nand_boot}/oftree-${global.board.variant}-setupfw.dtb"
+
+		else
+			echo -e ${error} "$0: No EMMC nor FLASH found. Nothing useful to do here, bailing out ..."
+			#all_lights -s 1 -c red
+			exit 1
+		fi
+	else
+		echo -e ${error} "$0: tftp download failed."
+		#all_lights -s 1 -c red
+		exit 1
+	fi
+else
+	echo -e ${error} "$0: dhcp configuration not set correctly."
+	#all_lights -s 1 -c red
+	exit 1
+fi
diff --git a/defaultenv/defaultenv-pfc-base/boot/sd-legacy b/defaultenv/defaultenv-pfc-base/boot/sd-legacy
new file mode 100644
index 00000000000..04c4223c333
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/boot/sd-legacy
@@ -0,0 +1,8 @@
+#!/bin/sh
+
+# We need to define an imaginary mtd-partition
+# to protect our flash if an FW < 5 is booted via sd-card. The customer could
+# break his device when the create-boot-image is executed via e.g. wbm.
+
+global.bootm.image="${global.pfc.sd_boot}/uImage"
+global.linux.bootargs.base="rw root=/dev/mmcblk0p2 rootfstype=ext3 rootwait mtdparts=omap2-nand.0:-(nand_not_valid)ro pxc_boot_id=0x82 bootversion=${global.version} devconf=0x${global.pfc.devconf} macaddr=${eth0.ethaddr}"
diff --git a/defaultenv/defaultenv-pfc-base/boot/sd-setupfw b/defaultenv/defaultenv-pfc-base/boot/sd-setupfw
new file mode 100644
index 00000000000..249247a3728
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/boot/sd-setupfw
@@ -0,0 +1,4 @@
+#!/bin/sh
+
+global.bootm.image="${global.pfc.sd_boot}/setupfw"
+global.bootm.oftree="${global.pfc.sd_boot}/oftree-${global.board.variant}-setupfw.dtb"
diff --git a/defaultenv/defaultenv-pfc-base/config b/defaultenv/defaultenv-pfc-base/config
new file mode 100644
index 00000000000..325c0c96d44
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/config
@@ -0,0 +1,225 @@
+#!/bin/sh
+
+# Here we setup the pfc environment for the start up scripts. Use global
+# variables because they make the sub-scripts more readable and can be
+# evaluated via commandline (e.g. magicvar command) if only booted to shell.
+
+############################
+# global variable definition
+############################
+global pfc.boot_mode
+global pfc.devconf
+global pfc.boot_mode_id
+global pfc.boot_mode_id_ext
+global pfc.ethaddr_is_valid
+global pfc.downgrade_img
+global pfc.custom_sh
+global pfc.sd
+global pfc.sd_boot
+global pfc.sd_rootfs
+global pfc.sd_dev_boot
+global pfc.sd_dev_rootfs
+global pfc.emmc_name
+global pfc.emmc
+global pfc.emmc_dev_boot
+global pfc.emmc_dev_rootfs0
+global pfc.emmc_dev_rootfs1
+global pfc.emmc_dev_home0
+global pfc.emmc_dev_home1
+global pfc.emmc_boot
+global pfc.emmc_rootfs0
+global pfc.emmc_rootfs1
+global pfc.nand
+global pfc.nand_ubidata
+global pfc.nand_ubidata_rootfs0
+global pfc.nand_ubidata_rootfs1
+global pfc.nand_ubidata_boot
+global pfc.nand_rootfs0
+global pfc.nand_rootfs1
+global pfc.nand_boot
+global pfc.nand_mlo_parts
+global pfc.nand_boot_parts
+global pfc.barebox_uart
+global pfc.barebox_linux_uart
+global pfc.linux_uart
+global pfc.eth
+global pfc.debug_mode_active
+global pfc.watchdog_timeout_linux_load
+global pfc.watchdog_timeout_linux_boot
+global pfc.linux_uart_device
+global pfc.eeprom_dev
+global pfc.usbgadget_options
+global pfc.disable_sd_boot
+global pfc.dhcpboot
+
+global bootchooser.rootfs.1.boot
+global bootchooser.rootfs.2.boot
+global linux.bootargs.productionmode
+global linux.bootargs.watchdog
+
+################################
+# global variable description
+################################
+magicvar -a global.pfc.boot_mode	"indicates boot state of this pfc device
+                                         possible values are:
+					 <default, production, setupfw, broken>"
+
+magicvar -a global.pfc.devconf		"copy value from eeprom xsection"
+magicvar -a global.pfc.boot_mode_id	"copy value from eeprom xsection"
+magicvar -a global.pfc.boot_mode_id_ext	"copy value from eeprom xsection"
+
+magicvar -a global.pfc.ethaddr_is_valid	"indicates if the configured ethaddr of
+					 eth0 is valid. Is valid when it matches
+					 the pattern 00:30:de possible values
+					 are: <valid, not_valid>"
+
+magicvar -a global.pfc.downgrade_img	"path to the downgrade image file on the
+					 sd card vfat boot partition"
+
+magicvar -a global.pfc.custom_sh	"path to the custom-setup script file on
+					 the sd card vfat boot partition"
+
+magicvar -a global.pfc.sd		"path to the sd card device"
+magicvar -a global.pfc.sd_boot		"path to the sd cards boot partition"
+magicvar -a global.pfc.sd_rootfs	"path to the sd cards rootfs partition"
+magicvar -a global.pfc.sd_dev_boot	"path to the sd cards boot partition
+					 device"
+
+magicvar -a global.pfc.sd_dev_rootfs	"path to the sd cards rootfs partition
+					 device"
+
+magicvar -a global.pfc.emmc_name	"name of the emmc in /dev"
+magicvar -a global.pfc.emmc		"path to the emmc device"
+magicvar -a global.pfc.emmc_dev_boot	"path to the emmc boot device"
+magicvar -a global.pfc.emmc_dev_rootfs0	"path to the emmc rootfs0 device"
+magicvar -a global.pfc.emmc_dev_rootfs1	"path to the emmc rootfs1 device"
+magicvar -a global.pfc.emmc_dev_home0	"path to the emmc home0 device"
+magicvar -a global.pfc.emmc_dev_home1	"path to the emmc home1 device"
+magicvar -a global.pfc.emmc_boot	"path to emmcs boot partition"
+magicvar -a global.pfc.emmc_rootfs0	"path to emmcs rootfs0 partition"
+magicvar -a global.pfc.emmc_rootfs1	"path to emmcs rootfs1 partition"
+magicvar -a global.pfc.nand		"path to the nand device"
+magicvar -a global.pfc.nand_ubidata	"path to the nand ubidata device"
+magicvar -a global.pfc.nand_ubidata_rootfs0 "path to the nand ubidata rootfs0
+					     device"
+
+magicvar -a global.pfc.nand_ubidata_rootfs1 "path to the nand ubidata rootfs1
+					     device"
+
+magicvar -a global.pfc.nand_ubidata_boot "path to the nand ubidata boot device"
+
+magicvar -a global.pfc.nand_rootfs0	"path to the nand rootfs0 partition"
+magicvar -a global.pfc.nand_rootfs1	"path to the nand rootfs1 partition"
+magicvar -a global.pfc.nand_boot	"path to the nand boot partition"
+magicvar -a global.pfc.nand_mlo_parts	"list of mlo partition paths"
+magicvar -a global.pfc.nand_boot_parts  "list of barebox (2nd stage) partition paths"
+magicvar -a global.pfc.barebox_uart	"uart device that is used in barebox for
+					 console messages"
+
+magicvar -a global.pfc.barebox_linux_uart "uart device that is used in linux for
+					    console messages, when uart bit is
+					    disabled and developer bit is
+					    enabled. E.g. in AM35xx barebox uart
+					    is 3 but corrosponding linux uart is
+					    2."
+
+
+magicvar -a global.pfc.linux_uart	"uart device that that the kernel uses
+					 for console messages"
+
+magicvar -a global.pfc.eth		"ethernet device that is used in all pfc
+					 devices"
+
+magicvar -a global.pfc.debug_mode_active "true if debug mode bit in boot_mode_id
+					  is set; false otherwise"
+
+magicvar -a global.pfc.watchdog_timeout_linux_load "watchdog timeout when trying
+						    to load the linux kernel in
+						    to ram"
+
+magicvar -a global.pfc.watchdog_timeout_linux_boot "watchdog timeout when trying
+						    to boot the linux kernel. Is
+						    resetted when the kernel driver
+						    is probed"
+
+magicvar -a global.pfc.linux_uart_device "uart device string that is used when
+					  configuring the kernel parameter (e.g
+					  ttyO, ttymxc)."
+
+
+magicvar -a global.linux.bootargs.productionmode "parameter for starting setupfw
+						  in production or wsc mode"
+magicvar -a global.linux.bootargs.watchdog "board specific watchdog kernel parameter"
+magicvar -a global.pfc.eeprom_dev "path to eeprom device"
+magicvar -a global.pfc.usbgadget_options "options to activate when usbgadget is
+					  used. By default fastboot-, fastboot
+					  bbu- and CDC ACM-Functions are
+					  activated"
+magicvar -a global.pfc.disable_sd_boot "is set during boot phase and disables sd
+					firmware boot, Mode is derived from
+					boot-mode-id-ext."
+magicvar -a global.pfc.dhcpboot "is set during boot and enables dhcpboot mode
+				based on the flag in boot-mode-id-ext."
+
+
+
+################################
+# global variable initialisation
+################################
+[ -z "${global.pfc.boot_mode}" ] && global.pfc.boot_mode="${bootmatrix.mode}"
+[ -z "${global.pfc.devconf}" ] && global.pfc.devconf="${xsection.devconf}"
+[ -z "${global.pfc.boot_mode_id}" ] && global.pfc.boot_mode_id="${xsection.boot_mode_id}"
+[ -z "${global.pfc.boot_mode_id_ext}" ] && global.pfc.boot_mode_id_ext="${xsection.boot_mode_id_ext}"
+[ -z "${global.pfc.ethaddr_is_valid}" ] && global.pfc.ethaddr_is_valid=false
+[ -z "${global.pfc.sd}" ] && global.pfc.sd="/dev/mmc0"
+[ -z "${global.pfc.sd_boot}" ] && global.pfc.sd_boot="/mnt/sd_boot"
+[ -z "${global.pfc.sd_rootfs}" ] && global.pfc.sd_rootfs="/mnt/sd_rootfs"
+[ -z "${global.pfc.sd_dev_boot}" ] && global.pfc.sd_dev_boot="${global.pfc.sd}.0"
+[ -z "${global.pfc.sd_dev_rootfs}" ] && global.pfc.sd_dev_rootfs="${global.pfc.sd}.1"
+[ -z "${global.pfc.emmc_name}" ] && global.pfc.emmc_name="mmc1"
+[ -z "${global.pfc.emmc}" ] && global.pfc.emmc="/dev/${global.pfc.emmc_name}"
+[ -z "${global.pfc.emmc_dev_boot}" ] && global.pfc.emmc_dev_boot="${global.pfc.emmc}.0"
+[ -z "${global.pfc.emmc_dev_rootfs0}" ] && global.pfc.emmc_dev_rootfs0="${global.pfc.emmc}.4"
+[ -z "${global.pfc.emmc_dev_rootfs1}" ] && global.pfc.emmc_dev_rootfs1="${global.pfc.emmc}.7"
+[ -z "${global.pfc.emmc_dev_home0}" ] && global.pfc.emmc_dev_home0="${global.pfc.emmc}.5"
+[ -z "${global.pfc.emmc_dev_home1}" ] && global.pfc.emmc_dev_home1="${global.pfc.emmc}.6"
+[ -z "${global.pfc.emmc_boot}" ] && global.pfc.emmc_boot="/mnt/mmc1.0"
+[ -z "${global.pfc.emmc_rootfs0}" ] && global.pfc.emmc_rootfs0="/mnt/emmc_rootfs0"
+[ -z "${global.pfc.emmc_rootfs1}" ] && global.pfc.emmc_rootfs1="/mnt/emmc_rootfs1"
+[ -z "${global.pfc.nand}" ] && global.pfc.nand="/dev/nand0"
+[ -z "${global.pfc.nand_ubidata}" ] && global.pfc.nand_ubidata="${global.pfc.nand}.ubidata"
+[ -z "${global.pfc.nand_ubidata_rootfs0}" ] && global.pfc.nand_ubidata_rootfs0="${global.pfc.nand}.ubidata.ubi.rootfs.1"
+[ -z "${global.pfc.nand_ubidata_rootfs1}" ] && global.pfc.nand_ubidata_rootfs1="${global.pfc.nand}.ubidata.ubi.rootfs.2"
+[ -z "${global.pfc.nand_ubidata_boot}" ] && global.pfc.nand_ubidata_boot="${global.pfc.nand}.ubidata.ubi.boot"
+[ -z "${global.pfc.nand_rootfs0}" ] && global.pfc.nand_rootfs0="/mnt/ubi_rootfs0"
+[ -z "${global.pfc.nand_rootfs1}" ] && global.pfc.nand_rootfs1="/mnt/ubi_rootfs1"
+[ -z "${global.pfc.nand_boot}" ] && global.pfc.nand_boot="/mnt/ubi_boot"
+[ -z "${global.pfc.nand_mlo_parts}" ] && global.pfc.nand_mlo_parts="${global.pfc.nand}.mlo0 ${global.pfc.nand}.mlo1 ${global.pfc.nand}.mlo2 ${global.pfc.nand}.mlo3"
+[ -z "${global.pfc.nand_boot_parts}" ] && global.pfc.nand_boot_parts="${global.pfc.nand}.boot0 ${global.pfc.nand}.boot1 ${global.pfc.nand}.boot2 ${global.pfc.nand}.boot3"
+[ -z "${global.pfc.eeprom_dev}" ] && global.pfc.eeprom_dev="/dev/eeprom0"
+
+[ -z "${global.pfc.downgrade_img}" ] && global.pfc.downgrade_img="${global.pfc.sd_boot}/downgrade.bin.$global.board.variant"
+[ -z "${global.pfc.custom_sh}" ] && global.pfc.custom_sh="${global.pfc.sd_boot}/custom_setup.sh"
+[ -z "${global.pfc.barebox_uart}" ] && global.pfc.barebox_uart="0"
+[ -z "${global.pfc.barebox_linux_uart}" ] && global.pfc.barebox_linux_uart="0"
+[ -z "${global.pfc.linux_uart}" ] && global.pfc.linux_uart="1"
+[ -z "${global.pfc.eth}" ] && global.pfc.eth="eth0"
+[ -z "${global.pfc.debug_mode_active}" ] && global.pfc.debug_mode_active=false
+[ -z "${global.pfc.watchdog_timeout_linux_load}" ] && global.pfc.watchdog_timeout_linux_load=10
+[ -z "${global.pfc.watchdog_timeout_linux_boot}" ] && global.pfc.watchdog_timeout_linux_boot=30
+[ -z "${global.pfc.debug_mode_active}" ] && global.pfc.debug_mode_active=false
+[ -z "${global.pfc.linux_uart_device}" ] && global.pfc.linux_uart_device="ttyO"
+[ -z "${global.pfc.usbgadget_options}" ] && global.pfc.usbgadget_options="-A -b -a"
+[ -z "${global.pfc.disable_sd_boot}" ] && global.pfc.disable_sd_boot=0
+[ -z "${global.pfc.dhcpboot}" ] && global.pfc.dhcpboot=0
+
+[ -z "${global.bootchooser.targets}" ] && global.bootchooser.targets="rootfs.1 rootfs.2"
+[ -z "${global.bootchooser.state_prefix}" ] && global.bootchooser.state_prefix="bootstate"
+[ -z "${global.bootchooser.reset_attempts}" ] && global.bootchooser.reset_attempts="all-zero power-on"
+[ -z "${global.bootchooser.reset_priorities}" ] && global.bootchooser.reset_priorities="all-zero"
+[ -z "${global.bootchooser.disable_on_zero_attempts}" ] && global.bootchooser.disable_on_zero_attempts=0
+[ -z "${global.bootchooser.retry}" ] && global.bootchooser.retry=1
+
+[ -z "${global.linux.bootargs.watchdog}" ] && global.linux.bootargs.watchdog="omap_wdt.early_enable omap_wdt.timer_margin=${global.pfc.watchdog_timeout_linux_boot}"
+[ -z "${global.fastboot.bbu}" ] && global.fastboot.bbu=1
+[ -z "${global.fastboot.partitions}" ] && global.fastboot.partitions="/kernel(kernel)c,/initrd(initrd)c,/devicetree(devicetree)c,${global.pfc.emmc_dev_boot}(boot)c,${global.pfc.emmc_dev_rootfs0}(rootfs1)c,${global.pfc.emmc_dev_rootfs1}(rootfs2)c,${global.pfc.sd_dev_boot}(boot_sd)c,${global.pfc.sd_dev_rootfs}(rootfs_sd)c,${global.pfc.eeprom_dev}(eeprom)c,${global.pfc.emmc_dev_home0}(home1)c,${global.pfc.emmc_dev_home1}(home2)c,/parttable(parttable)c"
diff --git a/defaultenv/defaultenv-pfc-base/data/print-msg-formats b/defaultenv/defaultenv-pfc-base/data/print-msg-formats
new file mode 100644
index 00000000000..3442e996794
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/data/print-msg-formats
@@ -0,0 +1,9 @@
+#!/bin/sh
+
+# here we are defining some print messages formats,
+# that are sourced and used in scripts.
+
+info="\e[00;32mINFO: PFC\e[00m: "
+error="\e[00;31mERROR: PFC\e[00m: "
+warning="\e[00;33mWARN: PFC\e[00m: "
+
diff --git a/defaultenv/defaultenv-pfc-base/init/automount b/defaultenv/defaultenv-pfc-base/init/automount
new file mode 100644
index 00000000000..527b363de77
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init/automount
@@ -0,0 +1,8 @@
+#!/bin/sh
+
+[ -e "${global.pfc.nand_ubidata}" ] && automount -d ${global.pfc.nand_rootfs0} "[ ! -e ${global.pfc.nand_ubidata_rootfs0} ] && ubiattach ${global.pfc.nand_ubidata}; mount -t ubifs ${global.pfc.nand_ubidata_rootfs0} ${global.pfc.nand_rootfs0}"
+[ -e "${global.pfc.nand_ubidata}" ] && automount -d ${global.pfc.nand_rootfs1} "[ ! -e ${global.pfc.nand_ubidata_rootfs1} ] && ubiattach ${global.pfc.nand_ubidata}; mount -t ubifs ${global.pfc.nand_ubidata_rootfs1} ${global.pfc.nand_rootfs1}"
+[ -e "${global.pfc.emmc_dev_rootfs0}" ] && automount -d ${global.pfc.emmc_rootfs0} "mount ${global.pfc.emmc_dev_rootfs0} ${global.pfc.emmc_rootfs0}"
+[ -e "${global.pfc.emmc_dev_rootfs1}" ] && automount -d ${global.pfc.emmc_rootfs1} "mount ${global.pfc.emmc_dev_rootfs1} ${global.pfc.emmc_rootfs1}"
+[ -e "${global.pfc.sd_dev_rootfs}" ] && automount -d ${global.pfc.sd_rootfs} "mount ${global.pfc.sd_dev_rootfs} ${global.pfc.sd_rootfs}"
+[ -e "${global.pfc.sd_dev_boot}" ] && automount -d ${global.pfc.sd_boot} "mount ${global.pfc.sd_dev_boot} ${global.pfc.sd_boot}"
diff --git a/defaultenv/defaultenv-pfc-base/init/pfc-max-tftp-bsize b/defaultenv/defaultenv-pfc-base/init/pfc-max-tftp-bsize
new file mode 100644
index 00000000000..1045e1acf77
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init/pfc-max-tftp-bsize
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+global.tftp.blocksize=1432
diff --git a/defaultenv/defaultenv-pfc-base/init/z-pfc-config-startup b/defaultenv/defaultenv-pfc-base/init/z-pfc-config-startup
new file mode 100644
index 00000000000..d597e55ef39
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init/z-pfc-config-startup
@@ -0,0 +1,43 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+pfc-detect-boot-mode
+
+if [ "${global.pfc.boot_mode}" = "default" ]; then
+	pfc-config-default-boot
+	if [ "$?" = 1 ]; then
+		echo -e ${error} "$0: could not configure default boot"
+		pfc-config-broken-boot
+		exit 1
+	fi
+
+elif [ "${global.pfc.boot_mode}" = "production" ]; then
+	pfc-config-production-boot
+
+elif [ "${global.pfc.boot_mode}" = "setupfw" ]; then
+	pfc-config-setupfw-boot
+
+elif [ "${global.pfc.boot_mode}" = "downgrade" ]; then
+	pfc-exec-downgrade-boot
+	if [ "$?" = 1 ]; then
+		echo -e ${error} "$0: failed to execute downgrade boot"
+		led_mode -s -c yellow -v off
+		led_mode -s -c red -v on
+		exit 1
+	fi
+
+elif [ "${global.pfc.boot_mode}" = "custom" ]; then
+	pfc-exec-custom-boot
+	if [ "$?" = 1 ]; then
+		echo -e ${error} "$0: failed to execute custom script"
+		led_mode -s -c yellow -v off
+		led_mode -s -c red -v on
+		exit 1
+	fi
+
+else
+	pfc-config-broken-boot
+	exit 1
+fi
+
diff --git a/defaultenv/defaultenv-pfc-base/init_post_autoboot/a-pfc-switch-reset b/defaultenv/defaultenv-pfc-base/init_post_autoboot/a-pfc-switch-reset
new file mode 100644
index 00000000000..7eaded01c57
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init_post_autoboot/a-pfc-switch-reset
@@ -0,0 +1,24 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+# Hint: on am35xx based devices we do not need to get the switch out of reset
+# manually. This is already done by the hardware reset-logic.
+
+if [ "${global.autoboot}" = 0 -a "${global.pfc.boot_mode}" = "default" ]; then
+	exit 0
+fi
+
+if [ "${global.pfc.sw_reset_gpio}" = "" ] || [ ${global.pfc.sw_reset_gpio} -eq -1 ]; then
+	echo -e ${warning} "no switch reset pin defined for board \e[00;32m${global.board.variant}\e[00m"
+	exit 0
+else
+	echo -n -e ${info} "reset switch for board \e[00;32m${global.board.variant}\e[00m with gpio pin "
+	echo "${global.pfc.sw_reset_gpio}"
+fi
+
+gpio_direction_output "${global.pfc.sw_reset_gpio}" 0
+msleep 1
+gpio_direction_output "${global.pfc.sw_reset_gpio}" 1
+# give the switch and phys some time to wakeup from reset
+msleep 1000
diff --git a/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-disable-wdg b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-disable-wdg
new file mode 100644
index 00000000000..93301e8197c
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-disable-wdg
@@ -0,0 +1,5 @@
+#!/bin/sh
+
+if [ "${global.autoboot}" != 0 ] || [ "${global.pfc.boot_mode}" != "default" ] && [ "${global.pfc.boot_mode}" != "broken" ]; then
+	global.boot.watchdog_timeout=0
+fi
diff --git a/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-ksz8863-setup b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-ksz8863-setup
new file mode 100644
index 00000000000..79d7cfca4c7
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-ksz8863-setup
@@ -0,0 +1,60 @@
+#!/bin/sh
+
+# To determine if we are on a micrel ks8863 based device we can not read then
+# switch identifier register. This lack comes due to an unssported operation code
+# of the cpu to get the values from the micrel ethernet switch. Instead we read
+# the interal phy_id registers of the micrel switch.
+
+source env/data/print-msg-formats
+
+# mii bus
+mii_bus=0
+
+# mii addresses
+phy_x1_addr=1
+phy_x2_addr=2
+
+# registers
+control_reg=0
+phy_id_high_reg=2
+phy_id_low_reg=3
+
+# register values
+#
+# Init values according to Data Sheet:
+# "AN enable" (Auto-negotiation enabled) = 1
+# "Hp_mdix" (HP Auto MDI/MDI-X mode) = 1
+#
+auto_neg_mdi_enable=4128	# 0x1020
+phy_id_high_val=34		# 0x22
+phy_id_low_val=5168		# 0x1430
+
+if [ "${global.autoboot}" = 0 -a "${global.pfc.boot_mode}" = "default" ]; then
+	exit 0
+fi
+
+# read phy id regs to check if we are on a micrel based device. Its sufficient to
+# read only the phy id of phy_x1.
+miitool -x "${mii_bus}:${phy_x1_addr}:${phy_id_high_reg}" -p read_phy_id_high_val
+miitool -x "${mii_bus}:${phy_x1_addr}:${phy_id_low_reg}" -p read_phy_id_low_val
+
+if [ "${read_phy_id_high_val}" != "${phy_id_high_val}" ] && [ "${read_phy_id_low_val}" != "${phy_id_low_reg}" ]; then
+	exit 0
+fi
+
+echo -e ${info} "Micrel KSZ8863 switch detected"
+
+# enable auto-negotiation and auto-mdi-x mode
+miitool -w "${mii_bus}:${phy_x1_addr}:${control_reg}" -p auto_neg_mdi_enable
+if [ "$?" != 0 ]; then
+	echo -e ${error} "Could not enable auto-neg-mdi PHY of port X1"
+	exit 1
+fi
+
+miitool -w "${mii_bus}:${phy_x2_addr}:${control_reg}" -p auto_neg_mdi_enable
+if [ "$?" != 0 ]; then
+	echo -e ${error} "Could not enable auto-neg-mdi PHY of port X2"
+	exit 1
+fi
+
+exit 0
diff --git a/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-mv88e6321-setup b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-mv88e6321-setup
new file mode 100644
index 00000000000..f05cfd518e1
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-mv88e6321-setup
@@ -0,0 +1,173 @@
+#!/bin/sh
+
+# mii bus
+mii_bus=0
+
+# mii addresses
+sw_port0_addr=16
+g2_addr=28
+
+# mii registers
+sw_id_reg=3
+sw_port_status_reg=0
+g2_smi_cmd_reg=24
+g2_smi_data_reg=25
+
+# constants / flags
+mv88e6321_product_id=784
+
+sw_port_phy_detect_flag="0x1000"
+
+smi_busy_flag="0x8000"
+smi_cmd_c22_mode="0x1000"
+smi_cmd_write="0x400"
+smi_cmd_read="0x800"
+
+phy_power_down_flag="0x800"
+
+source env/data/print-msg-formats
+
+if [ "${global.autoboot}" = 0 -a "${global.pfc.boot_mode}" = "default" ]; then
+	exit 0
+fi
+
+miitool -x "${mii_bus}:${sw_port0_addr}:${sw_id_reg}" -p switch_id
+if [ "$?" != 0 ]; then
+	exit 0
+fi
+
+# ignore chip reversion
+let switch_product_id="${switch_id} >> 4"
+
+if [ ${switch_product_id} != ${mv88e6321_product_id} ]; then
+	exit 0
+fi
+
+echo -e ${info} "Marvel MV88E6321 switch detected"
+
+# set phy detection flag
+miitool -x "${mii_bus}:${sw_port0_addr}:${sw_port_status_reg}" -p sw_port0_status
+if [ "$?" != 0 ]; then
+	echo -e ${error} "Could not read switch port0 status"
+	exit 1
+fi
+
+let sw_port0_new_status="${sw_port0_status} | ${sw_port_phy_detect_flag}"
+
+miitool -w "${mii_bus}:${sw_port0_addr}:${sw_port_status_reg}" -p sw_port0_new_status
+if [ "$?" != 0 ]; then
+	echo -e ${error} "Could not write new switch port0 status"
+	exit 1
+fi
+
+# power up external phy
+
+# wait for SMI command ready
+smi_busy=1
+smi_tries=3
+
+# the device address is in bits 9:5 of the smi command
+# ports 0, 1, 3, 4
+for device_address in 0 32 96 128; do
+
+	while [ "${smi_busy}" != 0 ]; do
+		miitool -x "${mii_bus}:${g2_addr}:${g2_smi_cmd_reg}" -p g2_smi_cmd
+		if [ "$?" != 0 ]; then
+			echo -e ${error} "Could not read switch G2 SMI command register"
+			exit 1
+		fi
+
+		let smi_busy="${g2_smi_cmd} & ${smi_busy_flag}"
+
+		let smi_tries="${smi_tries} - 1"
+
+		if [ "${smi_busy}" != 0 ]; then
+			if [ "${smi_tries}" = 0 ]; then
+				echo -e ${error} "Switch SMI busy"
+				exit 1
+			else
+				sleep 1
+			fi
+		fi
+	done
+
+	# set power down of phy control register to zero
+	let g2_smi_cmd="${smi_busy_flag} | ${smi_cmd_c22_mode} | ${smi_cmd_read} | ${device_address}"
+	miitool -w "${mii_bus}:${g2_addr}:${g2_smi_cmd_reg}" -p g2_smi_cmd
+	if [ "$?" != 0 ]; then
+		echo -e ${error} "Could not write G2 SMI command"
+		exit 1
+	fi
+
+	miitool -x "${mii_bus}:${g2_addr}:${g2_smi_data_reg}" -p g2_smi_data
+	if [ "$?" != 0 ]; then
+		echo -e ${error} "Could not read G2 SMI data"
+		exit 1
+	fi
+
+	let g2_smi_data="${g2_smi_data} & ~${phy_power_down_flag}"
+
+	miitool -w "${mii_bus}:${g2_addr}:${g2_smi_data_reg}" -p g2_smi_data
+	if [ "$?" != 0 ]; then
+		echo -e ${error} "Could not write G2 SMI data"
+		exit 1
+	fi
+
+	smi_busy=1
+	smi_tries=3
+
+	while [ "${smi_busy}" != 0 ]; do
+		miitool -x "${mii_bus}:${g2_addr}:${g2_smi_cmd_reg}" -p g2_smi_cmd
+		if [ "$?" != 0 ]; then
+			echo -e ${error} "Could not read switch G2 SMI command register"
+			exit 1
+		fi
+
+		let smi_busy="${g2_smi_cmd} & ${smi_busy_flag}"
+
+		let smi_tries="${smi_tries} - 1"
+
+		if [ "${smi_busy}" != 0 ]; then
+			if [ "${smi_tries}" = 0 ]; then
+				echo -e ${error} "Switch SMI busy"
+				exit 1
+			else
+				sleep 1
+			fi
+		fi
+	done
+
+	let g2_smi_cmd="${smi_busy_flag} | ${smi_cmd_c22_mode} | ${smi_cmd_write} | ${device_address}"
+	miitool -w "${mii_bus}:${g2_addr}:${g2_smi_cmd_reg}" -p g2_smi_cmd
+	if [ "$?" != 0 ]; then
+		echo -e ${error} "Could not write G2 SMI command"
+		exit 1
+	fi
+
+	# wait until phy is ready
+	smi_busy=1
+	smi_ties=3
+
+	while [ "${smi_busy}" != 0 ]; do
+		miitool -x "${mii_bus}:${g2_addr}:${g2_smi_cmd_reg}" -p g2_smi_cmd
+		if [ "$?" != 0 ]; then
+			echo -e ${error} "Could not read switch G2 SMI command register"
+			exit 1
+		fi
+
+		let smi_busy="${g2_smi_cmd} & ${smi_busy_flag}"
+
+		let smi_tries="${smi_tries} - 1"
+
+		if [ "${smi_busy}" != 0 ]; then
+			if [ "${smi_tries}" = 0 ]; then
+				echo -e ${error} "Switch SMI busy"
+				exit 1
+			else
+				sleep 1
+			fi
+		fi
+	done
+done
+
+exit 0
diff --git a/drivers/i2c/busses/i2c-omap.c b/drivers/i2c/busses/i2c-omap.c
index d3f525f333c..45d06eb2ec3 100644
--- a/drivers/i2c/busses/i2c-omap.c
+++ b/drivers/i2c/busses/i2c-omap.c
@@ -1121,7 +1121,10 @@ i2c_omap_probe(struct device_d *pdev)
 	 * Also since the omap_i2c_read_reg uses reg_map_ip_* a
 	 * raw_readw is done.
 	 */
-	rev = __raw_readw(i2c_omap->base + 0x04);
+	if (!of_machine_is_compatible("ti,omap3") && !of_machine_is_compatible("ti,omap2"))
+		rev = __raw_readw(i2c_omap->base + 0x04);
+	else
+		rev = 0;
 
 	i2c_omap->scheme = OMAP_I2C_SCHEME(rev);
 	switch (i2c_omap->scheme) {
diff --git a/drivers/mci/mci-core.c b/drivers/mci/mci-core.c
index a160b988945..df16ef23e3f 100644
--- a/drivers/mci/mci-core.c
+++ b/drivers/mci/mci-core.c
@@ -19,6 +19,7 @@
 #include <block.h>
 #include <disks.h>
 #include <of.h>
+#include <of_gpio.h>
 #include <linux/err.h>
 #include <linux/sizes.h>
 
@@ -1663,6 +1664,16 @@ static const char *mci_boot_names[] = {
 	"user",
 };
 
+static int mci_get_cd(struct param_d *param, void *priv)
+{
+	struct mci *mci = priv;
+	struct mci_host *host = mci->host;
+
+	mci->cd = host->card_present(host);
+
+	return 0;
+}
+
 static int mci_register_partition(struct mci_part *part)
 {
 	struct mci *mci = part->mci;
@@ -1811,6 +1822,10 @@ static int mci_card_probe(struct mci *mci)
 		}
 	}
 
+	if (!mci->param_cd && host->card_present)
+		mci->param_cd = dev_add_param_bool(&mci->dev, "cd", NULL,
+						mci_get_cd, &mci->cd, mci);
+
 	dev_dbg(&mci->dev, "SD Card successfully added\n");
 
 on_error:
@@ -2016,6 +2031,8 @@ void mci_of_parse_node(struct mci_host *host,
 
 	host->non_removable = of_property_read_bool(np, "non-removable");
 	host->no_sd = of_property_read_bool(np, "no-sd");
+	host->cd_gpio = of_get_named_gpio(np, "cd-gpios", 0);
+	host->cd_inverted = of_property_read_bool(np, "cd-inverted");
 }
 
 void mci_of_parse(struct mci_host *host)
diff --git a/drivers/mci/stm32_sdmmc2.c b/drivers/mci/stm32_sdmmc2.c
index 0c620427ee4..0b82f794e66 100644
--- a/drivers/mci/stm32_sdmmc2.c
+++ b/drivers/mci/stm32_sdmmc2.c
@@ -7,6 +7,7 @@
 #include <common.h>
 #include <dma.h>
 #include <init.h>
+#include <gpio.h>
 #include <linux/amba/bus.h>
 #include <linux/iopoll.h>
 #include <linux/log2.h>
@@ -571,6 +572,18 @@ static void stm32_sdmmc2_set_ios(struct mci_host *mci, struct mci_ios *ios)
 	       priv->base + SDMMC_CLKCR);
 }
 
+static int mmc_card_present(struct mci_host *mci)
+{
+	if (mci->non_removable)
+		return 1;
+
+	if (!gpio_is_valid(mci->cd_gpio) || gpio_direction_input(mci->cd_gpio))
+		return 0;
+
+	return mci->cd_inverted ? !gpio_get_value(mci->cd_gpio) :
+				   gpio_get_value(mci->cd_gpio);
+}
+
 static int stm32_sdmmc2_probe(struct amba_device *adev,
 			      const struct amba_id *id)
 {
@@ -589,6 +602,7 @@ static int stm32_sdmmc2_probe(struct amba_device *adev,
 	mci->send_cmd = stm32_sdmmc2_send_cmd;
 	mci->set_ios = stm32_sdmmc2_set_ios;
 	mci->init = stm32_sdmmc2_reset;
+	mci->card_present = mmc_card_present;
 	mci->hw_dev = dev;
 
 	priv->clk = clk_get(dev, NULL);
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 87674a2a29f..3922032034e 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -42,4 +42,16 @@ config ACPI_TEST
 	help
 	  This is a simple Test driver to test the ACPI bus.
 
+config XSECTION
+	bool "Xsection driver"
+	help
+	  Controls the XSECTION items that are located e.g. in eeprom like
+	  devconf, boot-mode-id and ethaddr.
+
+config BOOTMATRIX
+	bool "Bootmatrix Driver"
+	help
+	  Detects the boot mode based on pressed keys and exports the boot mode
+	  as a device parameter.
+
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 4d92465a1e5..a2b6ef70325 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -8,3 +8,5 @@ obj-$(CONFIG_STATE_DRV)		+= state.o
 obj-$(CONFIG_DEV_MEM)		+= mem.o
 obj-$(CONFIG_UBOOTVAR)		+= ubootvar.o
 obj-$(CONFIG_ACPI_TEST)		+= acpi-test.o
+obj-$(CONFIG_XSECTION)		+= xsection.o
+obj-$(CONFIG_BOOTMATRIX)	+= bootmatrix.o
diff --git a/drivers/misc/bootmatrix.c b/drivers/misc/bootmatrix.c
new file mode 100644
index 00000000000..9524ed7d1e2
--- /dev/null
+++ b/drivers/misc/bootmatrix.c
@@ -0,0 +1,355 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <driver.h>
+#include <init.h>
+#include <malloc.h>
+#include <of.h>
+#include <libbb.h>
+#include <fcntl.h>
+#include <linux/err.h>
+#include <gpio.h>
+#include <of_gpio.h>
+#include <linux/types.h>
+#include <linux/bitmap.h>
+#include <bootmatrix.h>
+#include <led_mode.h>
+
+#define MAX_KEY_BITS 8
+
+enum bootmatrix_states {
+	INIT,
+	MULTI_KEY_MODE,
+	SINGLE_KEY_MODE_STAGE1,
+	SINGLE_KEY_MODE_STAGE2,
+};
+
+enum bootmatrix_key_num {
+	RST = 0,
+	RUN,
+	STOP,
+	RESET,
+};
+
+struct bootmatrix_key {
+	int gpio;
+	int active_low;
+};
+
+struct bootmatrix {
+	struct device_d dev;
+	struct bootmatrix_key *keys;
+	struct param_d *param_mode;
+	int num_bootmatrix_keys;
+	int rst_timeout;
+	int mode;
+	bool single_key_mode;
+	DECLARE_BITMAP(matrix, MAX_KEY_BITS);
+};
+
+struct bootmatrix *bootmatrix;
+
+static void bootmatrix_get_current_key_values(struct bootmatrix *bootmatrix)
+{
+	int i, val, pressed;
+	struct bootmatrix_key *key;
+
+	bitmap_zero(bootmatrix->matrix, MAX_KEY_BITS);
+
+	for (i = RST; i < bootmatrix->num_bootmatrix_keys; i++) {
+
+		key = &bootmatrix->keys[i];
+		val = gpio_get_value(key->gpio);
+		pressed = val != key->active_low;
+
+		if (pressed)
+			set_bit(i, bootmatrix->matrix);
+	}
+}
+
+/* We implement the following two logics to detect the bootmode:
+ *
+ * SINGLE_KEY_MODE: some device have only one RST-key implemented. In this case
+ * the production mode is detected when the half of the configured timeout is
+ * reached. The setupfw mode is detected when the full configured timeout is
+ * reached.
+ *
+ * MULTI_KEY_MODE: this mode is the original mode for devices that have the keys
+ * RUN,STOP,RESET and RST implemented. For entering the setupfw mode one has to
+ * hold RST and RESET for a minimum of 7 sec. If one releases the RESET key the
+ * device enters production mode. In all other cases we will fallback into the
+ * default mode.
+ */
+static enum bootmatrix_mode bootmatrix_detect_mode(struct bootmatrix
+							*bootmatrix)
+{
+	enum bootmatrix_mode mode = DEFAULT;
+	enum bootmatrix_states state = INIT;
+	unsigned long *matrix = bootmatrix->matrix;
+	bool exit = false;
+	bool single_key = bootmatrix->single_key_mode;
+	int timeout = bootmatrix->rst_timeout;
+	uint64_t start;
+
+	bootmatrix_get_current_key_values(bootmatrix);
+	if (test_bit(RST, matrix) && (test_bit(RESET, matrix) || single_key)) {
+
+		led_mode_static("green", true);
+
+		start = get_time_ns();
+		while (!exit) {
+
+			bootmatrix_get_current_key_values(bootmatrix);
+			switch (state) {
+			case INIT:
+				if (!test_bit(RST, matrix)) {
+					mode = DEFAULT;
+					exit = true;
+				} else if (single_key && test_bit(RST, matrix)) {
+					state = SINGLE_KEY_MODE_STAGE1;
+				} else if (test_bit(RST, matrix) &&
+						test_bit(RESET, matrix)) {
+					state = MULTI_KEY_MODE;
+				}
+				break;
+
+			case SINGLE_KEY_MODE_STAGE1:
+				if (!test_bit(RST, matrix)) {
+					mode = DEFAULT;
+					exit = true;
+				} else if (is_timeout(start, (timeout / 2) *
+								      SECOND)) {
+					mode = PRODUCTION;
+					state = SINGLE_KEY_MODE_STAGE2;
+					led_mode_static("green", false);
+				}
+				break;
+
+			case SINGLE_KEY_MODE_STAGE2:
+				if (!test_bit(RST, matrix)) {
+					exit = true;
+				} else if (is_timeout(start, timeout * SECOND)) {
+					mode = SETUPFW;
+					exit = true;
+				}
+				break;
+
+			case MULTI_KEY_MODE:
+				if (!test_bit(RST, matrix)) {
+					mode = DEFAULT;
+					exit = true;
+				} else if (!test_bit(RESET, matrix) &&
+							test_bit(STOP, matrix)) {
+					mode = PRODUCTION;
+					exit = true;
+				} else if (is_timeout(start, timeout * SECOND)) {
+					mode = SETUPFW;
+					exit = true;
+				}
+				break;
+			}
+		}
+	}
+
+	return mode;
+}
+
+enum bootmatrix_mode bootmatrix_get_mode()
+{
+	if (!bootmatrix)
+		return -ENODEV;
+
+	if (bootmatrix->mode == UNKNOWN)
+		return -EPROBE_DEFER;
+
+	return bootmatrix->mode;
+}
+
+static int bootmatrix_probe_key(struct device_node *node,
+					struct bootmatrix_key *key, char *name)
+{
+	struct device_node *child;
+	enum of_gpio_flags flags;
+	int ret = 0;
+
+	child = of_find_node_by_name(node, name);
+	if (!child) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	key->gpio = of_get_named_gpio_flags(child, "gpios", 0, &flags);
+	if (key->gpio < 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (flags & OF_GPIO_ACTIVE_LOW)
+		key->active_low = 1;
+
+	ret = gpio_request(key->gpio, name);
+	if (ret)
+		goto out;
+
+	ret = gpio_direction_input(key->gpio);
+
+out:
+	return ret < 0 ? ret : 0;
+}
+
+static int bootmatrix_probe_dt(struct bootmatrix *bootmatrix,
+				   struct device_node *node)
+{
+	int ret = 0;
+
+	bootmatrix->num_bootmatrix_keys = of_get_child_count(node);
+	bootmatrix->keys = xzalloc(bootmatrix->num_bootmatrix_keys *
+						sizeof(*bootmatrix->keys));
+
+	if (bootmatrix->num_bootmatrix_keys < 1) {
+		ret = -ENODEV;
+		goto out_free;
+	} else if (bootmatrix->num_bootmatrix_keys == 1) {
+		bootmatrix->single_key_mode = true;
+	} else {
+		bootmatrix->single_key_mode = false;
+	}
+
+	ret = of_property_read_u32(node, "rst-timeout-secs",
+						&bootmatrix->rst_timeout);
+	if (ret)
+		goto out_free;
+
+	ret = bootmatrix_probe_key(node, &bootmatrix->keys[RST], "rst");
+	if (ret)
+		goto out_free;
+
+	/* in single-key-mode we need only the rst key. if we found this key
+	 * terminate here.
+	 */
+	if (bootmatrix->single_key_mode)
+		goto out;
+
+	ret = bootmatrix_probe_key(node, &bootmatrix->keys[RUN], "run");
+	if (ret)
+		goto out_free;
+
+	ret = bootmatrix_probe_key(node, &bootmatrix->keys[STOP], "stop");
+	if (ret)
+		goto out_free;
+
+	ret = bootmatrix_probe_key(node, &bootmatrix->keys[RESET], "reset");
+	if (ret)
+		goto out_free;
+
+out:
+	return 0;
+
+out_free:
+	free(bootmatrix->keys);
+	return ret;
+}
+
+static const char *bootmatrix_mode_names[] = {
+	"unknown",
+	"default",
+	"production",
+	"setupfw",
+};
+
+static int bootmatrix_probe(struct device_d *dev)
+{
+	int ret;
+	const char *alias;
+	struct device_node *np = dev->device_node;
+
+	bootmatrix = xzalloc(sizeof(*bootmatrix));
+	bootmatrix->dev.id = DEVICE_ID_SINGLE;
+	bootmatrix->dev.parent = dev;
+	dev->priv = bootmatrix;
+
+	if (!np) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	ret = bootmatrix_probe_dt(bootmatrix, np);
+	if (ret)
+		goto out;
+
+	alias = of_alias_get(np);
+	if (!alias) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	dev_set_name(&bootmatrix->dev, alias);
+
+	ret = register_device(&bootmatrix->dev);
+	if (ret)
+		goto out;
+
+	bootmatrix->param_mode = dev_add_param_enum(&bootmatrix->dev, "mode",
+				NULL, NULL,
+				&bootmatrix->mode,
+				bootmatrix_mode_names,
+				ARRAY_SIZE(bootmatrix_mode_names),
+				bootmatrix);
+
+	if (IS_ERR(bootmatrix->param_mode)) {
+		ret = -ENODEV;
+		goto out_unreg;
+	}
+
+	bootmatrix->mode = bootmatrix_detect_mode(bootmatrix);
+
+	return 0;
+
+out_unreg:
+	unregister_device(&bootmatrix->dev);
+
+out:
+	free(bootmatrix);
+	dev_err(dev, "failed to probe %d\n", ret);
+
+	return ret;
+}
+
+static void bootmatrix_remove(struct device_d *dev)
+{
+	struct bootmatrix *bootmatrix = dev->priv;
+
+	dev_remove_parameters(&bootmatrix->dev);
+	unregister_device(&bootmatrix->dev);
+	free(bootmatrix->keys);
+	free(bootmatrix);
+}
+
+static __maybe_unused struct of_device_id bootmatrix_ids[] = {
+	{
+		.compatible = "bootmatrix",
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct driver_d bootmatrix_driver = {
+	.name = "bootmatrix",
+	.probe = bootmatrix_probe,
+	.remove = bootmatrix_remove,
+	.of_compatible = DRV_OF_COMPAT(bootmatrix_ids),
+};
+device_platform_driver(bootmatrix_driver);
diff --git a/drivers/misc/xsection.c b/drivers/misc/xsection.c
new file mode 100644
index 00000000000..79c43f0df81
--- /dev/null
+++ b/drivers/misc/xsection.c
@@ -0,0 +1,459 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <init.h>
+#include <malloc.h>
+#include <of.h>
+#include <libbb.h>
+#include <fcntl.h>
+#include <linux/err.h>
+#include <net.h>
+#include <xsection.h>
+#include <fs.h>
+
+struct xsection_item {
+	struct cdev *cdev;
+	char *value_param;
+};
+
+struct xsection {
+	struct device_d dev;
+	struct xsection_item boot_mode_id;
+	struct xsection_item boot_mode_id_ext;
+	struct xsection_item devconf;
+	struct xsection_item ethaddr1;
+	struct xsection_item ethaddr2;
+	struct xsection_item blidx;
+	struct xsection_item blp_uii;
+};
+
+static struct xsection *xsection;
+
+static int xsection_access_item(struct xsection_item *xitem, void *buf,
+								int flags)
+{
+	int ret = 0;
+
+	if (!xitem || !buf || flags < 0)
+		return -EINVAL;
+
+	switch (flags) {
+	case O_RDONLY:
+		ret = cdev_read(xitem->cdev, buf, xitem->cdev->size, 0, 0);
+		break;
+	case O_WRONLY:
+		ret = cdev_write(xitem->cdev, buf, xitem->cdev->size, 0, 0);
+		break;
+	}
+
+	return ret;
+}
+
+int xsection_get_boot_mode_id(u8 *buf)
+{
+	return xsection ? xsection_access_item(&xsection->boot_mode_id, buf,
+							O_RDONLY) : -ENODEV;
+}
+
+int xsection_set_boot_mode_id(u8 *value)
+{
+	return xsection ? xsection_access_item(&xsection->boot_mode_id, value,
+							O_WRONLY) : -ENODEV;
+}
+
+int xsection_get_boot_mode_id_ext(u8 *buf)
+{
+	return xsection ? xsection_access_item(&xsection->boot_mode_id_ext, buf,
+							O_RDONLY) : -ENODEV;
+}
+
+int xsection_set_boot_mode_id_ext(u8 *value)
+{
+	return xsection ? xsection_access_item(&xsection->boot_mode_id_ext, value,
+							O_WRONLY) : -ENODEV;
+}
+int xsection_get_devconf(u16 *buf)
+{
+	return xsection ? xsection_access_item(&xsection->devconf, buf,
+							O_RDONLY) : -ENODEV;
+}
+
+int xsection_set_devconf(u16 *value)
+{
+	return xsection ? xsection_access_item(&xsection->devconf, value,
+							O_WRONLY) : -ENODEV;
+}
+
+int xsection_get_ethaddr1(u8 ethaddr[6])
+{
+	return xsection ? xsection_access_item(&xsection->ethaddr1, ethaddr,
+							O_RDONLY) : -ENODEV;
+}
+
+int xsection_set_ethaddr1(u8 ethaddr[6])
+{
+	return xsection ? xsection_access_item(&xsection->ethaddr1, ethaddr,
+							O_WRONLY) : -ENODEV;
+}
+
+int xsection_get_ethaddr2(u8 ethaddr[6])
+{
+	return xsection ? xsection_access_item(&xsection->ethaddr2, ethaddr,
+							O_RDONLY) : -ENODEV;
+}
+
+int xsection_set_ethaddr2(u8 ethaddr[6])
+{
+	return xsection ? xsection_access_item(&xsection->ethaddr2, ethaddr,
+							O_WRONLY) : -ENODEV;
+}
+
+static int xsection_param_get_ethaddr(struct xsection_item *xitem)
+{
+	int ret;
+	u8 buf[6];
+
+	ret = xsection_access_item(xitem, &buf, O_RDONLY);
+	if (ret < 0)
+		return ret;
+
+	free(xitem->value_param);
+	xitem->value_param = xzalloc(sizeof("xx:xx:xx:xx:xx:xx"));
+
+	ethaddr_to_string(buf, xitem->value_param);
+
+	return 0;
+}
+
+static int xsection_param_set_ethaddr(struct xsection_item *xitem)
+{
+	int ret;
+	u8 buf[6];
+
+	if (!strcmp(xitem->value_param, ""))
+		return -EINVAL;
+
+	ret = string_to_ethaddr(xitem->value_param, buf);
+	if (ret)
+		return ret;
+
+	ret = xsection_access_item(xitem, &buf, O_WRONLY);
+
+	return ret < 0 ? ret : 0;
+}
+
+static int xsection_param_get_ethaddr2(struct param_d *p, void *priv)
+{
+	return xsection_param_get_ethaddr(priv);
+}
+
+static int xsection_param_set_ethaddr2(struct param_d *p, void *priv)
+{
+	return xsection_param_set_ethaddr(priv);
+}
+
+static int xsection_param_get_ethaddr1(struct param_d *p, void *priv)
+{
+	return xsection_param_get_ethaddr(priv);
+}
+
+static int xsection_param_set_ethaddr1(struct param_d *p, void *priv)
+{
+	return xsection_param_set_ethaddr(priv);
+}
+
+static int xsection_param_get_boot_mode_id(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u8 buf;
+
+	ret = xsection_access_item(xitem, &buf, O_RDONLY);
+	if (ret < 0)
+		return ret;
+
+	free(xitem->value_param);
+	xitem->value_param = basprintf("%02x", buf);
+
+	return 0;
+}
+
+static int xsection_param_set_boot_mode_id(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u8 value;
+
+	if (!strcmp(xitem->value_param, ""))
+		return -EINVAL;
+
+	value = simple_strtoul(xitem->value_param, NULL, 0);
+	ret = xsection_access_item(xitem, &value, O_WRONLY);
+
+	return ret < 0 ? ret : 0;
+}
+
+static int xsection_param_get_devconf(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u16 buf;
+
+	ret = xsection_access_item(xitem, &buf, O_RDONLY);
+	if (ret < 0)
+		return ret;
+
+	free(xitem->value_param);
+	xitem->value_param = basprintf("%04x", buf);
+
+	return 0;
+}
+
+static int xsection_param_set_devconf(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u16 value;
+
+	if (!strcmp(xitem->value_param, ""))
+		return -EINVAL;
+
+	value = simple_strtoul(xitem->value_param, NULL, 0);
+	ret = xsection_access_item(xitem, &value, O_WRONLY);
+
+	return ret < 0 ? ret : 0;
+}
+
+static int xsection_param_get_blidx(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u8 buf;
+
+	ret = xsection_access_item(xitem, &buf, O_RDONLY);
+	if (ret < 0)
+		return ret;
+
+	free(xitem->value_param);
+	xitem->value_param = basprintf("%d", buf);
+
+	return 0;
+}
+
+static int xsection_param_set_blidx(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u8 value;
+
+	if (!strcmp(xitem->value_param, ""))
+		return -EINVAL;
+
+	value = simple_strtoul(xitem->value_param, NULL, 0);
+	ret = xsection_access_item(xitem, &value, O_WRONLY);
+
+	return ret < 0 ? ret : 0;
+}
+
+static int xsection_param_get_blp_uii(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u8 buf[40];
+
+	ret = xsection_access_item(xitem, &buf, O_RDONLY);
+	if (ret < 0)
+		return ret;
+
+	/* replace last byte with terminating null byte to avoid garbage in the
+	 * string device parameter.
+	 */
+	buf[39] = '\0';
+
+	free(xitem->value_param);
+	xitem->value_param = basprintf("%s", buf);
+
+	return 0;
+}
+
+static int xsection_param_set_blp_uii(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+
+	if (!strcmp(xitem->value_param, "") || strlen(xitem->value_param) != 39)
+		return -EINVAL;
+
+	/* we need to set a <EOT> sign at the end per definition */
+	xitem->value_param[39] = 0x04;
+	ret = xsection_access_item(xitem, xitem->value_param, O_WRONLY);
+
+	return ret < 0 ? ret : 0;
+}
+static int xsection_add_dev_param(struct device_node *np,
+				struct xsection *xsection,
+				struct xsection_item *xitem, char *param_name,
+				int (*set)(struct param_d *p, void *priv),
+				int (*get)(struct param_d *p, void *priv))
+{
+	struct device_node *partition_node;
+	struct cdev *cdev;
+	struct param_d *param;
+	int ret = 0;
+	char *device_path;
+
+	partition_node = of_parse_phandle(np, param_name, 0);
+	if (!partition_node) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	ret = of_find_path_by_node(partition_node, &device_path, 0);
+	if (ret == -EPROBE_DEFER)
+		goto out;
+
+	cdev = cdev_by_name(devpath_to_name(device_path));
+	if (!cdev) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	param = dev_add_param_string(&xsection->dev, param_name, set, get,
+				&xitem->value_param, xitem);
+
+	if (IS_ERR(param)) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	xitem->cdev = cdev;
+
+out:
+	return ret;
+}
+
+static int xsection_probe(struct device_d *dev)
+{
+	struct device_node *np = dev->device_node;
+	const char *alias;
+	int ret;
+
+	xsection = xzalloc(sizeof(*xsection));
+	xsection->dev.id = DEVICE_ID_SINGLE;
+	xsection->dev.parent = dev;
+	dev->priv = xsection;
+
+	alias = of_alias_get(np);
+	if (!alias) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	dev_set_name(&xsection->dev, alias);
+
+	ret = register_device(&xsection->dev);
+	if (ret)
+		goto out;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->boot_mode_id,
+					"boot_mode_id",
+					xsection_param_set_boot_mode_id,
+					xsection_param_get_boot_mode_id);
+	if (ret)
+		goto out_unreg;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->boot_mode_id_ext,
+					"boot_mode_id_ext",
+					xsection_param_set_boot_mode_id,
+					xsection_param_get_boot_mode_id);
+	if (ret)
+		goto out_unreg;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->devconf,
+					"devconf",
+					xsection_param_set_devconf,
+					xsection_param_get_devconf);
+	if (ret)
+		goto out_unreg;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->ethaddr1,
+					"ethaddr1",
+					 xsection_param_set_ethaddr1,
+					 xsection_param_get_ethaddr1);
+	if (ret)
+		goto out_unreg;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->ethaddr2,
+					"ethaddr2",
+					 xsection_param_set_ethaddr2,
+					 xsection_param_get_ethaddr2);
+	if (ret)
+		goto out_unreg;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->blidx,
+					"blidx",
+					 xsection_param_set_blidx,
+					 xsection_param_get_blidx);
+	if (ret)
+		goto out_unreg;
+
+	/* blp_uii is currently only used in pfc200 adv devices. So it's ok when
+	 * no "blp_uii" partition is found.
+	 */
+	xsection_add_dev_param(np, xsection, &xsection->blp_uii,
+					"blp_uii",
+					 xsection_param_set_blp_uii,
+					 xsection_param_get_blp_uii);
+
+	return 0;
+
+out_unreg:
+	unregister_device(&xsection->dev);
+out:
+	free(xsection);
+	xsection = NULL;
+
+	if (ret != -EPROBE_DEFER)
+		dev_err(dev, "failed to probe %d\n", ret);
+
+	return ret;
+}
+
+static void xsection_remove(struct device_d *dev)
+{
+	struct xsection *xsection = dev->priv;
+
+	dev_remove_parameters(&xsection->dev);
+	unregister_device(&xsection->dev);
+	free(xsection);
+	xsection = NULL;
+}
+
+static __maybe_unused struct of_device_id xsection_ids[] = {
+	{
+		.compatible = "xsection",
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct driver_d xsection_driver = {
+	.name = "xsection",
+	.probe = xsection_probe,
+	.remove = xsection_remove,
+	.of_compatible = DRV_OF_COMPAT(xsection_ids),
+};
+device_platform_driver(xsection_driver);
diff --git a/drivers/net/davinci_emac.c b/drivers/net/davinci_emac.c
index ff35b746e21..c0fd4cb7179 100644
--- a/drivers/net/davinci_emac.c
+++ b/drivers/net/davinci_emac.c
@@ -113,6 +113,9 @@ static int wait_for_user_access(struct davinci_mdio_priv *priv, uint32_t *val)
 	u32 tmp;
 	uint64_t start = get_time_ns();
 
+	if(readl(priv->adap_mdio + EMAC_MDIO_CONTROL) & MDIO_CONTROL_IDLE)
+		davinci_eth_mdio_enable(priv);
+
 	do {
 		tmp = readl(priv->adap_mdio + EMAC_MDIO_USERACCESS0);
 
diff --git a/images/Makefile.stm32mp b/images/Makefile.stm32mp
index 3384f5014bb..7b74408d481 100644
--- a/images/Makefile.stm32mp
+++ b/images/Makefile.stm32mp
@@ -32,3 +32,8 @@ pblb-$(CONFIG_MACH_STM32MP15X_EV1) += start_stm32mp15x_ev1
 FILE_barebox-stm32mp15x-ev1.img = start_stm32mp15x_ev1.pblb.stm32
 OPTS_start_stm32mp15x_ev1.pblb.stm32 = $(STM32MP1_OPTS)
 image-$(CONFIG_MACH_STM32MP15X_EV1) += barebox-stm32mp15x-ev1.img
+
+pblb-$(CONFIG_MACH_STM32MP151_CC100) += start_stm32mp151_cc100
+FILE_barebox-stm32mp151-cc100.img = start_stm32mp151_cc100.pblb.stm32
+OPTS_start_stm32mp151_cc100.pblb.stm32 = $(STM32MP1_OPTS)
+image-$(CONFIG_MACH_STM32MP151_CC100) += barebox-stm32mp151-cc100.img
diff --git a/include/blspec.h b/include/blspec.h
index 37076cd47c9..6815943de92 100644
--- a/include/blspec.h
+++ b/include/blspec.h
@@ -23,5 +23,6 @@ int blspec_scan_devices(struct bootentries *bootentries);
 int blspec_scan_device(struct bootentries *bootentries, struct device_d *dev);
 int blspec_scan_devicename(struct bootentries *bootentries, const char *devname);
 int blspec_scan_directory(struct bootentries *bootentries, const char *root);
+int blspec_scan_file(struct bootentries *bootentries, const char *file);
 
 #endif /* __LOADER_H__ */
diff --git a/include/bootmatrix.h b/include/bootmatrix.h
new file mode 100644
index 00000000000..b71121aae29
--- /dev/null
+++ b/include/bootmatrix.h
@@ -0,0 +1,13 @@
+#ifndef __BOOTMATRIX_H
+#define __BOOTMATRIX_H
+
+enum bootmatrix_mode {
+	UNKNOWN = 0,
+	DEFAULT,
+	PRODUCTION,
+	SETUPFW,
+};
+
+enum bootmatrix_mode bootmatrix_get_mode(void);
+
+#endif /* __BOOTMATRIX_H */
diff --git a/include/led_mode.h b/include/led_mode.h
new file mode 100644
index 00000000000..6a4e259f699
--- /dev/null
+++ b/include/led_mode.h
@@ -0,0 +1,10 @@
+#ifndef __LED_MODE_H
+#define __LED_MODE_H
+
+/* valid color strings are: red, green, yellow */
+int led_mode_static(char *color, bool state);
+
+/* valid color strings are: red, green */
+int led_mode_moving(char *color, unsigned int duration_ms, bool turn_off_anc);
+
+#endif /* __LED_MODE_H */
diff --git a/include/mci.h b/include/mci.h
index 5e6805e8dcd..882ef396596 100644
--- a/include/mci.h
+++ b/include/mci.h
@@ -405,6 +405,8 @@ struct mci_host {
 	bool non_removable;	/**< device is non removable */
 	bool no_sd;		/**< do not send SD commands during initialization */
 	struct regulator *supply;
+	int cd_gpio;            /**< card detection gpio pin */
+	bool cd_inverted;       /**< inverts cd_gpio value */
 
 	/** init the host interface */
 	int (*init)(struct mci_host*, struct device_d*);
@@ -459,6 +461,8 @@ struct mci {
 	int dsr_imp;		/**< DSR implementation state from CSD */
 	u8 *ext_csd;
 	int probe;
+	int cd;
+	struct param_d *param_cd;
 	struct param_d *param_boot;
 	int bootpart;
 
diff --git a/include/xsection.h b/include/xsection.h
new file mode 100644
index 00000000000..dfb3708dcba
--- /dev/null
+++ b/include/xsection.h
@@ -0,0 +1,19 @@
+#ifndef __XSECTION_H
+#define __XSECTION_H
+
+int xsection_get_boot_mode_id(u8 *buf);
+int xsection_set_boot_mode_id(u8 *value);
+
+int xsection_get_boot_mode_id_ext(u8 *buf);
+int xsection_set_boot_mode_id_ext(u8 *value);
+
+int xsection_get_devconf(u16 *buf);
+int xsection_set_devconf(u16 *value);
+
+int xsection_get_ethaddr1(u8 ethaddr[6]);
+int xsection_set_ethaddr1(u8 ethaddr[6]);
+
+int xsection_get_ethaddr2(u8 ethaddr[6]);
+int xsection_set_ethaddr2(u8 ethaddr[6]);
+
+#endif /* __XSECTION_H */
diff --git a/labgrid-wago b/labgrid-wago
new file mode 160000
index 00000000000..87b0374194a
--- /dev/null
+++ b/labgrid-wago
@@ -0,0 +1 @@
+Subproject commit 87b0374194a067eba4573bbeb5b688e389535aa1
diff --git a/localversion-wago b/localversion-wago
new file mode 100644
index 00000000000..131f86e13e4
--- /dev/null
+++ b/localversion-wago
@@ -0,0 +1 @@
+w04.00.00-cc100_13
